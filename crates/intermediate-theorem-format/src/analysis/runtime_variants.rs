// Copyright (c) Asymptotic Labs
// SPDX-License-Identifier: Apache-2.0

//! Generates .aborts and .pure variants for all runtime functions
//!
//! For each non-spec, non-native aborting function, this pass generates:
//! - `.aborts` : Prop - predicate indicating when the function aborts
//! - `.pure` : non-aborting version that calls other .pure functions
//!
//! The .aborts variant is generated by walking the body and:
//! - Keeping control flow (If, While, Let) as-is
//! - Wrapping aborting calls in: `if f.aborts(args) then True else ...`
//! - Converting `Abort` nodes to `True`
//! - Converting `Return` nodes to `False`

use crate::data::functions::FunctionVariant;
use crate::data::Program;
use crate::{BinOp, Const, FunctionID, IRNode, Type};
use std::collections::HashSet;

/// Create a Prop constant for False (rendered as False in Lean)
fn prop_false() -> IRNode {
    // We use ToProp(false) which renders as (false = true) ≡ False
    // This ensures the constant has type Prop
    IRNode::ToProp(Box::new(IRNode::Const(Const::Bool(false))))
}

/// Create a Prop-level Or: a ∨ b
fn prop_or(a: IRNode, b: IRNode) -> IRNode {
    IRNode::BinOp {
        op: BinOp::Or,
        lhs: Box::new(a),
        rhs: Box::new(b),
    }
}

/// Create a Prop-level And: a ∧ b
fn prop_and(a: IRNode, b: IRNode) -> IRNode {
    IRNode::BinOp {
        op: BinOp::And,
        lhs: Box::new(a),
        rhs: Box::new(b),
    }
}

/// Check if a node represents Prop false constant
fn is_prop_false(node: &IRNode) -> bool {
    match node {
        IRNode::ToProp(inner) => matches!(**inner, IRNode::Const(Const::Bool(false))),
        IRNode::Const(Const::Bool(false)) => true, // legacy
        _ => false,
    }
}

/// Ensure a node produces Bool type. If it's a Prop, wrap with ToBool.
fn ensure_bool(node: IRNode) -> IRNode {
    // If it's already wrapped with ToProp, unwrap it (ToProp(x) -> x where x is Bool)
    if let IRNode::ToProp(inner) = node {
        return *inner;
    }
    // Comparisons return Prop, need ToBool
    if let IRNode::BinOp { op, .. } = &node {
        if op.is_comparison() {
            return IRNode::ToBool(Box::new(node));
        }
    }
    // Already Bool or unknown - assume Bool
    node
}

/// Ensure a node produces Prop type. If it's a Bool, wrap with ToProp.
fn ensure_prop(node: IRNode) -> IRNode {
    // If it's already wrapped with ToBool, unwrap it (ToBool(x) -> x where x is Prop)
    if let IRNode::ToBool(inner) = node {
        return *inner;
    }
    // Comparisons already return Prop
    if let IRNode::BinOp { op, .. } = &node {
        if op.is_comparison() {
            return node;
        }
    }
    // Bool constants and other Bool expressions need ToProp
    if let IRNode::Const(Const::Bool(_)) = &node {
        return IRNode::ToProp(Box::new(node));
    }
    // Variables and other nodes - wrap with ToProp to be safe
    // This might create redundant wrapping but ensures correctness
    IRNode::ToProp(Box::new(node))
}

/// Generate .aborts and .pure variants for all runtime functions.
///
/// Prerequisites: `analyze_abortability` must have run first to set return types.
///
/// Note: We intentionally do NOT apply spec replacements here to avoid circular
/// dependencies. Spec replacements are only applied in Requires/Ensures variants
/// (in spec_generation.rs), not in Pure/Aborts variants.
pub fn generate_runtime_variants(program: &mut Program) {
    // Collect aborting runtime base function IDs (these will get Pure variants)
    let aborting_base_ids: HashSet<usize> = program
        .functions
        .iter()
        .filter(|(id, f)| id.is_runtime() && !f.is_spec() && !f.is_native() && f.can_abort())
        .map(|(id, _)| id.base)
        .collect();

    // Generate variants for each aborting function
    for &base_id in &aborting_base_ids {
        let func_id = FunctionID::new(base_id);
        let func_name = program.functions.get(&func_id).name.clone();

        // Generate .aborts variant - returns Prop (logical proposition)
        program.create_variant(func_id, FunctionVariant::Aborts, Type::Prop, |body| {
            let result = convert_to_aborts_predicate(body, &aborting_base_ids, &func_name);
            result.to_variant(FunctionVariant::Pure, |id| aborting_base_ids.contains(&id))
        });

        // Generate .pure variant - calls to aborting functions rewritten to Pure
        let return_type = program
            .functions
            .get(&func_id)
            .signature
            .return_type
            .base_type();
        program.create_variant(func_id, FunctionVariant::Pure, return_type, |body| {
            convert_to_pure(body)
                .to_variant(FunctionVariant::Pure, |id| aborting_base_ids.contains(&id))
        });
    }
}

/// Convert aborting IR to abort predicate (returns Prop).
///
/// Strategy:
/// - Walk the body, keeping control flow (If, While, Let) structure
/// - When we hit `let x := f(args)` where f can abort:
///   → `if f.aborts(args) then True else let x := f.pure(args) in ...`
/// - `Abort` → `True`
/// - `Return` → `False`
/// - Everything else passes through
fn convert_to_aborts_predicate(
    node: &IRNode,
    aborting_ids: &HashSet<usize>,
    _func_name: &str,
) -> IRNode {
    transform_to_aborts(node.clone(), aborting_ids)
}

/// Recursively transform an IR node to its abort predicate form.
fn transform_to_aborts(node: IRNode, aborting_ids: &HashSet<usize>) -> IRNode {
    let mut counter = 0;
    transform_to_aborts_impl(node, aborting_ids, &mut counter)
}

fn transform_to_aborts_impl(
    node: IRNode,
    aborting_ids: &HashSet<usize>,
    counter: &mut usize,
) -> IRNode {
    match node {
        // Block: transform sequentially, keeping necessary Let bindings for scope
        IRNode::Block { children } => {
            transform_block_to_aborts_impl(children, aborting_ids, counter)
        }

        // Let binding: extract all nested aborting calls from the value
        IRNode::Let { pattern, value } => {
            let (bindings, pure_value) =
                extract_aborts_with_bindings(&value, aborting_ids, counter);

            if bindings.is_empty() {
                // No aborting calls, just return False (the let is pure)
                prop_false()
            } else {
                // Build abort chain ending in False (let binding is just for scope here)
                let inner = IRNode::Block {
                    children: vec![
                        IRNode::Let {
                            pattern,
                            value: Box::new(pure_value),
                        },
                        prop_false(),
                    ],
                };
                build_abort_chain(bindings, inner)
            }
        }

        // If: keep structure, transform branches
        IRNode::If {
            cond,
            then_branch,
            else_branch,
        } => {
            // Extract aborts from condition
            let (cond_bindings, pure_cond) =
                extract_aborts_with_bindings(&cond, aborting_ids, counter);

            let then_aborts = transform_to_aborts_impl(*then_branch, aborting_ids, counter);
            let else_aborts = transform_to_aborts_impl(*else_branch, aborting_ids, counter);

            let then_is_false = is_prop_false(&then_aborts);
            let else_is_false = is_prop_false(&else_aborts);

            // Simplify based on branch results
            // Note: We use prop_and with the condition to avoid needing Decidable
            // Instead of: if cond then aborts else False
            // We use: cond ∧ aborts (for then branch) or ¬cond ∧ aborts (for else branch)
            let if_aborts = match (then_is_false, else_is_false) {
                (true, true) => prop_false(),
                (true, false) => {
                    // Only else can abort: ¬cond ∧ else_aborts
                    // We need ToBool on pure_cond since it's used in a Not which expects Bool
                    let cond_as_bool = ensure_bool(pure_cond.clone());
                    let not_cond = IRNode::UnOp {
                        op: crate::UnOp::Not,
                        operand: Box::new(cond_as_bool),
                    };
                    // Lift back to Prop for the And
                    prop_and(IRNode::ToProp(Box::new(not_cond)), else_aborts)
                }
                (false, true) => {
                    // Only then can abort: cond ∧ then_aborts
                    let cond_as_prop = ensure_prop(pure_cond);
                    prop_and(cond_as_prop, then_aborts)
                }
                (false, false) => {
                    // Both can abort: (cond ∧ then_aborts) ∨ (¬cond ∧ else_aborts)
                    let cond_as_bool = ensure_bool(pure_cond.clone());
                    let cond_as_prop = ensure_prop(pure_cond);
                    let not_cond = IRNode::UnOp {
                        op: crate::UnOp::Not,
                        operand: Box::new(cond_as_bool),
                    };
                    prop_or(
                        prop_and(cond_as_prop, then_aborts),
                        prop_and(IRNode::ToProp(Box::new(not_cond)), else_aborts),
                    )
                }
            };

            // Wrap with condition abort checks
            if cond_bindings.is_empty() {
                if_aborts
            } else {
                build_abort_chain(cond_bindings, if_aborts)
            }
        }

        // While: generate WhileAborts node to properly check all iterations
        //
        // WhileAborts(cond, body_aborts, body_pure, vars) iterates the loop:
        // - Returns True if any iteration has body_aborts = True
        // - Returns False if loop terminates without any iteration aborting
        IRNode::While {
            cond,
            body,
            vars,
            invariants,
        } => {
            let body_aborts = transform_to_aborts_impl((*body).clone(), aborting_ids, counter);

            if matches!(&body_aborts, IRNode::Const(Const::Bool(false))) {
                // Body never aborts in any iteration
                IRNode::Const(Const::Bool(false))
            } else {
                // Generate pure body by converting aborting calls to .pure
                let body_pure = convert_to_pure(&body);

                IRNode::WhileAborts {
                    cond,
                    body_aborts: Box::new(body_aborts),
                    body_pure: Box::new(body_pure),
                    vars,
                    invariants,
                }
            }
        }

        // Abort: always True
        IRNode::Abort(_) => IRNode::Const(Const::Bool(true)),

        // Return: always False (successful completion)
        IRNode::Return(_) => IRNode::Const(Const::Bool(false)),

        // Direct aborting call (not in a let): check if it aborts
        IRNode::Call {
            function,
            args,
            type_args,
        } if aborting_ids.contains(&function.base) => IRNode::Call {
            function: FunctionID {
                base: function.base,
                variant: FunctionVariant::Aborts,
            },
            args,
            type_args,
        },

        // Non-aborting call: check for nested aborting calls in arguments
        IRNode::Call { .. } => {
            let (bindings, _) = extract_aborts_with_bindings(&node, aborting_ids, counter);
            if bindings.is_empty() {
                IRNode::Const(Const::Bool(false))
            } else {
                let abort_conds: Vec<_> = bindings.into_iter().map(|(_, abort, _)| abort).collect();
                or_aborts(abort_conds)
            }
        }

        // Spec nodes: unwrap
        IRNode::Requires(inner) | IRNode::Ensures(inner) => {
            transform_to_aborts_impl(*inner, aborting_ids, counter)
        }

        // Other nodes: check for nested aborting calls
        _ => {
            let (bindings, _) = extract_aborts_with_bindings(&node, aborting_ids, counter);
            if bindings.is_empty() {
                IRNode::Const(Const::Bool(false))
            } else {
                let abort_conds: Vec<_> = bindings.into_iter().map(|(_, abort, _)| abort).collect();
                or_aborts(abort_conds)
            }
        }
    }
}

/// Transform a block's children to abort predicate form.
///
/// The key insight: we need to keep Let bindings for variables that are used
/// in abort conditions. So we process sequentially and wrap the continuation
/// in necessary Let bindings.
fn transform_block_to_aborts_impl(
    children: Vec<IRNode>,
    aborting_ids: &HashSet<usize>,
    counter: &mut usize,
) -> IRNode {
    if children.is_empty() {
        return IRNode::Const(Const::Bool(false));
    }

    // Process children in reverse order, building up the result
    let mut result = IRNode::Const(Const::Bool(false));

    for child in children.into_iter().rev() {
        match child {
            // Let binding: extract all nested aborting calls from the value
            IRNode::Let { pattern, value } => {
                // Extract all abort conditions from the value expression
                let (bindings, pure_value) =
                    extract_aborts_with_bindings(&value, aborting_ids, counter);

                if bindings.is_empty() {
                    // No aborting calls in this value, just wrap the let
                    result = IRNode::Block {
                        children: vec![
                            IRNode::Let {
                                pattern,
                                value: Box::new(pure_value),
                            },
                            result,
                        ],
                    };
                } else {
                    // Build abort chain: if abort1 then True else let tmp1 := pure1 in ...
                    // then at the end: let pattern := expr_with_tmps in <result>
                    let inner = IRNode::Block {
                        children: vec![
                            IRNode::Let {
                                pattern,
                                value: Box::new(pure_value),
                            },
                            result,
                        ],
                    };
                    result = build_abort_chain(bindings, inner);
                }
            }

            // If: transform branches using Prop-level operators (no if-then-else in aborts)
            IRNode::If {
                cond,
                then_branch,
                else_branch,
            } => {
                // Extract aborts from condition first
                let (cond_bindings, pure_cond) =
                    extract_aborts_with_bindings(&cond, aborting_ids, counter);

                let then_aborts = transform_to_aborts_impl(*then_branch, aborting_ids, counter);
                let else_aborts = transform_to_aborts_impl(*else_branch, aborting_ids, counter);

                let then_is_false = is_prop_false(&then_aborts);
                let else_is_false = is_prop_false(&else_aborts);

                // Use Prop-level operators instead of if-then-else to avoid Decidable
                let if_aborts = match (then_is_false, else_is_false) {
                    (true, true) => prop_false(),
                    (true, false) => {
                        // Only else can abort: ¬cond ∧ else_aborts
                        let cond_as_bool = ensure_bool(pure_cond.clone());
                        let not_cond = IRNode::UnOp {
                            op: crate::UnOp::Not,
                            operand: Box::new(cond_as_bool),
                        };
                        prop_and(IRNode::ToProp(Box::new(not_cond)), else_aborts)
                    }
                    (false, true) => {
                        // Only then can abort: cond ∧ then_aborts
                        let cond_as_prop = ensure_prop(pure_cond);
                        prop_and(cond_as_prop, then_aborts)
                    }
                    (false, false) => {
                        // Both can abort: (cond ∧ then_aborts) ∨ (¬cond ∧ else_aborts)
                        let cond_as_bool = ensure_bool(pure_cond.clone());
                        let cond_as_prop = ensure_prop(pure_cond);
                        let not_cond = IRNode::UnOp {
                            op: crate::UnOp::Not,
                            operand: Box::new(cond_as_bool),
                        };
                        prop_or(
                            prop_and(cond_as_prop, then_aborts),
                            prop_and(IRNode::ToProp(Box::new(not_cond)), else_aborts),
                        )
                    }
                };

                // First check condition aborts, then check if body aborts
                let if_with_cond_aborts = if cond_bindings.is_empty() {
                    if_aborts
                } else {
                    build_abort_chain(cond_bindings, if_aborts)
                };

                // Combine with continuation using OR
                result = or_nodes(if_with_cond_aborts, result);
            }

            // While: generate WhileAborts to properly check all iterations
            // Structure: whileAborts OR (let vars := whileLoopPure in continuation)
            IRNode::While {
                cond,
                body,
                vars,
                invariants,
            } => {
                let body_aborts = transform_to_aborts_impl((*body).clone(), aborting_ids, counter);
                let body_pure = convert_to_pure(&body);

                // Build the continuation that computes post-loop state
                let while_pure = IRNode::While {
                    cond: cond.clone(),
                    body: Box::new(body_pure.clone()),
                    vars: vars.clone(),
                    invariants: invariants.clone(),
                };

                // Wrap continuation in let binding to get post-loop values
                let continuation = if matches!(&result, IRNode::Const(Const::Bool(false))) {
                    result.clone()
                } else {
                    IRNode::Block {
                        children: vec![
                            IRNode::Let {
                                pattern: vars.clone(),
                                value: Box::new(while_pure),
                            },
                            result,
                        ],
                    }
                };

                // Build the full abort predicate
                if matches!(&body_aborts, IRNode::Const(Const::Bool(false))) {
                    // Body never aborts, just check continuation
                    result = continuation;
                } else {
                    let while_aborts = IRNode::WhileAborts {
                        cond,
                        body_aborts: Box::new(body_aborts),
                        body_pure: Box::new(body_pure),
                        vars,
                        invariants,
                    };
                    result = or_nodes(while_aborts, continuation);
                }
            }

            // Abort: True
            IRNode::Abort(_) => {
                result = or_nodes(IRNode::Const(Const::Bool(true)), result);
            }

            // Return: False (successful completion)
            IRNode::Return(_) => {
                // Return doesn't contribute to abort - just continue
            }

            // Direct aborting call (not in let): extract and check
            IRNode::Call { .. } => {
                let (bindings, _) = extract_aborts_with_bindings(&child, aborting_ids, counter);
                if !bindings.is_empty() {
                    // Just need the abort conditions, not the values
                    let abort_conds: Vec<_> =
                        bindings.into_iter().map(|(_, abort, _)| abort).collect();
                    let combined = or_aborts(abort_conds);
                    result = or_nodes(combined, result);
                }
            }

            // Other expressions: check for nested aborting calls
            _ => {
                let (bindings, _) = extract_aborts_with_bindings(&child, aborting_ids, counter);
                if !bindings.is_empty() {
                    let abort_conds: Vec<_> =
                        bindings.into_iter().map(|(_, abort, _)| abort).collect();
                    let combined = or_aborts(abort_conds);
                    result = or_nodes(combined, result);
                }
            }
        }
    }

    result
}

/// Combine two nodes with OR, simplifying if either is False.
fn or_nodes(a: IRNode, b: IRNode) -> IRNode {
    match (is_prop_false(&a), is_prop_false(&b)) {
        (true, true) => prop_false(),
        (true, false) => b,
        (false, true) => a,
        (false, false) => IRNode::BinOp {
            op: crate::BinOp::Or,
            lhs: Box::new(a),
            rhs: Box::new(b),
        },
    }
}

/// Extract abort conditions from an expression, recursively checking all sub-expressions.
/// This handles nested aborting calls like `f(g.aborting(x), y)`.
///
/// Returns a list of (abort_condition, pure_binding) pairs that need to be checked
/// in sequence before the expression can be safely evaluated.
fn extract_aborts_with_bindings(
    node: &IRNode,
    aborting_ids: &HashSet<usize>,
    counter: &mut usize,
) -> (Vec<(String, IRNode, IRNode)>, IRNode) {
    match node {
        // Monadic call: extract abort check and pure replacement
        // First, recursively extract aborts from arguments
        IRNode::Call {
            function,
            args,
            type_args,
        } if aborting_ids.contains(&function.base) => {
            let mut all_bindings = Vec::new();
            let mut new_args = Vec::new();

            // Recursively process arguments - they might contain nested aborting calls
            for arg in args {
                let (bindings, new_arg) = extract_aborts_with_bindings(arg, aborting_ids, counter);
                all_bindings.extend(bindings);
                new_args.push(new_arg);
            }

            let var_name = format!("$abort_tmp_{}", *counter);
            *counter += 1;

            // Use the transformed arguments (with temp vars) for both abort and pure calls
            let abort_call = IRNode::Call {
                function: FunctionID {
                    base: function.base,
                    variant: FunctionVariant::Aborts,
                },
                args: new_args.clone(),
                type_args: type_args.clone(),
            };

            let pure_call = IRNode::Call {
                function: FunctionID {
                    base: function.base,
                    variant: FunctionVariant::Pure,
                },
                args: new_args,
                type_args: type_args.clone(),
            };

            // Add this call's binding after the argument bindings
            all_bindings.push((var_name.clone(), abort_call, pure_call));

            (all_bindings, IRNode::Var(var_name))
        }

        // Non-aborting call: recursively check arguments
        IRNode::Call {
            function,
            args,
            type_args,
        } => {
            let mut all_bindings = Vec::new();
            let mut new_args = Vec::new();

            for arg in args {
                let (bindings, new_arg) = extract_aborts_with_bindings(arg, aborting_ids, counter);
                all_bindings.extend(bindings);
                new_args.push(new_arg);
            }

            let new_node = IRNode::Call {
                function: *function,
                args: new_args,
                type_args: type_args.clone(),
            };

            (all_bindings, new_node)
        }

        // Binary operations: check both operands
        IRNode::BinOp { op, lhs, rhs } => {
            let (lhs_bindings, new_lhs) = extract_aborts_with_bindings(lhs, aborting_ids, counter);
            let (rhs_bindings, new_rhs) = extract_aborts_with_bindings(rhs, aborting_ids, counter);

            let mut all_bindings = lhs_bindings;
            all_bindings.extend(rhs_bindings);

            let new_node = IRNode::BinOp {
                op: *op,
                lhs: Box::new(new_lhs),
                rhs: Box::new(new_rhs),
            };

            (all_bindings, new_node)
        }

        // Unary operations: check operand
        IRNode::UnOp { op, operand } => {
            let (bindings, new_operand) =
                extract_aborts_with_bindings(operand, aborting_ids, counter);

            let new_node = IRNode::UnOp {
                op: *op,
                operand: Box::new(new_operand),
            };

            (bindings, new_node)
        }

        // If expression: only extract from condition
        IRNode::If {
            cond,
            then_branch,
            else_branch,
        } => {
            // Only extract from condition (always evaluated)
            // Branches are conditionally evaluated - handled properly in transform_to_aborts_impl
            let (cond_bindings, new_cond) =
                extract_aborts_with_bindings(cond, aborting_ids, counter);

            let new_node = IRNode::If {
                cond: Box::new(new_cond),
                then_branch: then_branch.clone(),
                else_branch: else_branch.clone(),
            };

            (cond_bindings, new_node)
        }

        // Tuple: check all elements
        IRNode::Tuple(elems) => {
            let mut all_bindings = Vec::new();
            let mut new_elems = Vec::new();

            for elem in elems {
                let (bindings, new_elem) =
                    extract_aborts_with_bindings(elem, aborting_ids, counter);
                all_bindings.extend(bindings);
                new_elems.push(new_elem);
            }

            (all_bindings, IRNode::Tuple(new_elems))
        }

        // Field access: check base
        IRNode::Field {
            base,
            struct_id,
            field_index,
        } => {
            let (bindings, new_base) = extract_aborts_with_bindings(base, aborting_ids, counter);

            let new_node = IRNode::Field {
                base: Box::new(new_base),
                struct_id: *struct_id,
                field_index: *field_index,
            };

            (bindings, new_node)
        }

        // Pack: check all field values
        IRNode::Pack {
            struct_id,
            type_args,
            fields,
        } => {
            let mut all_bindings = Vec::new();
            let mut new_fields = Vec::new();

            for field in fields {
                let (bindings, new_field) =
                    extract_aborts_with_bindings(field, aborting_ids, counter);
                all_bindings.extend(bindings);
                new_fields.push(new_field);
            }

            let new_node = IRNode::Pack {
                struct_id: *struct_id,
                type_args: type_args.clone(),
                fields: new_fields,
            };

            (all_bindings, new_node)
        }

        // Abort: this is an abort condition itself
        IRNode::Abort(_) => {
            // Return True as abort condition, unit as replacement
            let var_name = format!("$abort_tmp_{}", *counter);
            *counter += 1;
            (
                vec![(
                    var_name.clone(),
                    IRNode::Const(Const::Bool(true)),
                    IRNode::unit(),
                )],
                IRNode::Var(var_name),
            )
        }

        // Leaf nodes: no aborts
        IRNode::Var(_) | IRNode::Const(_) => (vec![], node.clone()),

        // Other nodes: clone as-is (conservative)
        _ => (vec![], node.clone()),
    }
}

/// Build a chain of abort checks from bindings.
/// Each binding is (var_name, abort_condition, pure_value).
/// Returns: abort1 ∨ (let var1 := pure1 in abort2 ∨ (let var2 := pure2 in ...))
///
/// Uses logical OR instead of if-then-else because abort conditions are Props
/// and we want to avoid needing Decidable instances.
fn build_abort_chain(bindings: Vec<(String, IRNode, IRNode)>, continuation: IRNode) -> IRNode {
    bindings
        .into_iter()
        .rev()
        .fold(continuation, |cont, (var_name, abort_cond, pure_val)| {
            // Skip if abort condition is always False
            if matches!(&abort_cond, IRNode::Const(Const::Bool(false))) {
                IRNode::Block {
                    children: vec![
                        IRNode::Let {
                            pattern: vec![var_name],
                            value: Box::new(pure_val),
                        },
                        cont,
                    ],
                }
            } else {
                // Use OR instead of if-then-else to avoid needing Decidable
                // abort_cond ∨ (let var := pure_val in continuation)
                IRNode::BinOp {
                    op: crate::BinOp::Or,
                    lhs: Box::new(abort_cond),
                    rhs: Box::new(IRNode::Block {
                        children: vec![
                            IRNode::Let {
                                pattern: vec![var_name],
                                value: Box::new(pure_val),
                            },
                            cont,
                        ],
                    }),
                }
            }
        })
}

/// Combine multiple abort conditions with OR, filtering out False.
fn or_aborts(aborts: Vec<IRNode>) -> IRNode {
    let non_false: Vec<_> = aborts
        .into_iter()
        .filter(|n| !matches!(n, IRNode::Const(Const::Bool(false))))
        .collect();

    match non_false.len() {
        0 => IRNode::Const(Const::Bool(false)),
        1 => non_false.into_iter().next().unwrap(),
        _ => non_false
            .into_iter()
            .reduce(|acc, n| IRNode::BinOp {
                op: crate::BinOp::Or,
                lhs: Box::new(acc),
                rhs: Box::new(n),
            })
            .unwrap(),
    }
}

/// Convert aborting IR to pure (non-aborting) version.
/// - Simplify Ifs where branches always abort
/// - Filter out Abort nodes
/// - Unwrap Returns
pub fn convert_to_pure(node: &IRNode) -> IRNode {
    // First simplify If nodes where branches always abort
    let node = simplify_aborting_ifs(node.clone());

    // Remove Abort nodes and unwrap Returns
    node.map(&mut |n| match n {
        // Filter Abort nodes from Block children
        IRNode::Block { children } => {
            let filtered: Vec<_> = children
                .into_iter()
                .filter(|c| !matches!(c, IRNode::Abort(_)))
                .collect();
            IRNode::Block { children: filtered }
        }
        // Abort nodes that escape to expression position become unit
        IRNode::Abort(_) => IRNode::unit(),
        // Unwrap Returns
        IRNode::Return(vals) => {
            if vals.len() == 1 {
                vals.into_iter().next().unwrap()
            } else {
                IRNode::Tuple(vals)
            }
        }
        // Spec nodes shouldn't appear in runtime functions, unwrap them
        IRNode::Requires(inner) | IRNode::Ensures(inner) => *inner,
        other => other,
    })
}

/// Simplify If nodes where branches always abort.
/// - If both branches abort, replace with unit (unreachable)
/// - If only then branch aborts, keep else branch
/// - If only else branch aborts, keep then branch
///
/// We recursively simplify until no more changes occur, because
/// inner simplifications may cause outer ifs to become simplifiable.
fn simplify_aborting_ifs(node: IRNode) -> IRNode {
    let original = node.clone();
    let simplified = node.map(&mut |n| match n {
        IRNode::If {
            cond,
            then_branch,
            else_branch,
        } => {
            let then_always_aborts = then_branch.always_aborts();
            let else_always_aborts = else_branch.always_aborts();

            if then_always_aborts && else_always_aborts {
                IRNode::unit()
            } else if then_always_aborts {
                *else_branch
            } else if else_always_aborts {
                *then_branch
            } else {
                IRNode::If {
                    cond,
                    then_branch,
                    else_branch,
                }
            }
        }
        other => other,
    });

    // Continue simplifying until fixpoint (handles newly exposed abort patterns)
    if simplified == original {
        simplified
    } else {
        simplify_aborting_ifs(simplified)
    }
}
