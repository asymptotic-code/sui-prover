// Copyright (c) Asymptotic Labs
// SPDX-License-Identifier: Apache-2.0

//! Generates .aborts and .pure variants for all runtime functions
//!
//! For each non-spec, non-native monadic function, this pass generates:
//! - `.aborts` : Prop - predicate indicating when the function aborts
//! - `.pure` : non-monadic version that calls other .pure functions
//!
//! The .aborts variant is generated by walking the body and:
//! - Keeping control flow (If, While, Let) as-is
//! - Wrapping monadic calls in: `if f.aborts(args) then True else ...`
//! - Converting `Abort` nodes to `True`
//! - Converting `Return` nodes to `False`

use crate::data::functions::FunctionVariant;
use crate::data::Program;
use crate::{Const, FunctionID, IRNode, Type};
use std::collections::HashSet;

/// Generate .aborts and .pure variants for all runtime functions.
///
/// Prerequisites: `analyze_monadicity` must have run first to set return types.
///
/// Note: We intentionally do NOT apply spec replacements here to avoid circular
/// dependencies. Spec replacements are only applied in Requires/Ensures variants
/// (in spec_generation.rs), not in Pure/Aborts variants.
pub fn generate_runtime_variants(program: &mut Program) {
    // Collect monadic runtime base function IDs (these will get Pure variants)
    let monadic_base_ids: HashSet<usize> = program
        .functions
        .iter()
        .filter(|(id, f)| id.is_runtime() && !f.is_spec() && !f.is_native() && f.is_monadic())
        .map(|(id, _)| id.base)
        .collect();

    // Generate variants for each monadic function
    for &base_id in &monadic_base_ids {
        let func_id = FunctionID::new(base_id);
        let func_name = program.functions.get(&func_id).name.clone();

        // Generate .aborts variant
        program.create_variant(func_id, FunctionVariant::Aborts, Type::Bool, |body| {
            let result = convert_to_aborts_predicate(body, &monadic_base_ids, &func_name);
            result.to_variant(FunctionVariant::Pure, |id| monadic_base_ids.contains(&id))
        });

        // Generate .pure variant - calls to monadic functions rewritten to Pure
        let return_type = program.functions.get(&func_id).signature.return_type.base_type();
        program.create_variant(func_id, FunctionVariant::Pure, return_type, |body| {
            convert_to_pure(body)
                .to_variant(FunctionVariant::Pure, |id| monadic_base_ids.contains(&id))
        });
    }
}

/// Convert monadic IR to abort predicate (returns Prop).
///
/// Strategy:
/// - Walk the body, keeping control flow (If, While, Let) structure
/// - When we hit `let x := f(args)` where f is monadic:
///   → `if f.aborts(args) then True else let x := f.pure(args) in ...`
/// - `Abort` → `True`
/// - `Return` → `False`
/// - Everything else passes through
fn convert_to_aborts_predicate(node: &IRNode, monadic_ids: &HashSet<usize>, _func_name: &str) -> IRNode {
    transform_to_aborts(node.clone(), monadic_ids)
}

/// Recursively transform an IR node to its abort predicate form.
fn transform_to_aborts(node: IRNode, monadic_ids: &HashSet<usize>) -> IRNode {
    let mut counter = 0;
    transform_to_aborts_impl(node, monadic_ids, &mut counter)
}

fn transform_to_aborts_impl(node: IRNode, monadic_ids: &HashSet<usize>, counter: &mut usize) -> IRNode {
    match node {
        // Block: transform sequentially, keeping necessary Let bindings for scope
        IRNode::Block { children } => {
            transform_block_to_aborts_impl(children, monadic_ids, counter)
        }

        // Let binding: extract all nested monadic calls from the value
        IRNode::Let { pattern, value } => {
            let (bindings, pure_value) = extract_aborts_with_bindings(&value, monadic_ids, counter);

            if bindings.is_empty() {
                // No monadic calls, just return False (the let is pure)
                IRNode::Const(Const::Bool(false))
            } else {
                // Build abort chain ending in False (let binding is just for scope here)
                let inner = IRNode::Block {
                    children: vec![
                        IRNode::Let {
                            pattern,
                            value: Box::new(pure_value),
                        },
                        IRNode::Const(Const::Bool(false)),
                    ],
                };
                build_abort_chain(bindings, inner)
            }
        }

        // If: keep structure, transform branches
        IRNode::If { cond, then_branch, else_branch } => {
            // Extract aborts from condition
            let (cond_bindings, pure_cond) = extract_aborts_with_bindings(&cond, monadic_ids, counter);

            let then_aborts = transform_to_aborts_impl(*then_branch, monadic_ids, counter);
            let else_aborts = transform_to_aborts_impl(*else_branch, monadic_ids, counter);

            let then_is_false = matches!(&then_aborts, IRNode::Const(Const::Bool(false)));
            let else_is_false = matches!(&else_aborts, IRNode::Const(Const::Bool(false)));

            // Simplify based on branch results
            let if_aborts = match (then_is_false, else_is_false) {
                (true, true) => IRNode::Const(Const::Bool(false)),
                (true, false) => {
                    // Only else can abort: if !cond then else_aborts else False
                    IRNode::If {
                        cond: Box::new(IRNode::UnOp {
                            op: crate::UnOp::Not,
                            operand: Box::new(pure_cond),
                        }),
                        then_branch: Box::new(else_aborts),
                        else_branch: Box::new(IRNode::Const(Const::Bool(false))),
                    }
                }
                (false, true) => {
                    // Only then can abort: if cond then then_aborts else False
                    IRNode::If {
                        cond: Box::new(pure_cond),
                        then_branch: Box::new(then_aborts),
                        else_branch: Box::new(IRNode::Const(Const::Bool(false))),
                    }
                }
                (false, false) => {
                    // Both can abort: keep the if structure
                    IRNode::If {
                        cond: Box::new(pure_cond),
                        then_branch: Box::new(then_aborts),
                        else_branch: Box::new(else_aborts),
                    }
                }
            };

            // Wrap with condition abort checks
            if cond_bindings.is_empty() {
                if_aborts
            } else {
                build_abort_chain(cond_bindings, if_aborts)
            }
        }

        // While: generate WhileAborts node to properly check all iterations
        //
        // WhileAborts(cond, body_aborts, body_pure, vars) iterates the loop:
        // - Returns True if any iteration has body_aborts = True
        // - Returns False if loop terminates without any iteration aborting
        IRNode::While { cond, body, vars, invariants } => {
            let body_aborts = transform_to_aborts_impl((*body).clone(), monadic_ids, counter);

            if matches!(&body_aborts, IRNode::Const(Const::Bool(false))) {
                // Body never aborts in any iteration
                IRNode::Const(Const::Bool(false))
            } else {
                // Generate pure body by converting monadic calls to .pure
                let body_pure = convert_to_pure(&body);

                IRNode::WhileAborts {
                    cond,
                    body_aborts: Box::new(body_aborts),
                    body_pure: Box::new(body_pure),
                    vars,
                    invariants,
                }
            }
        }

        // Abort: always True
        IRNode::Abort(_) => IRNode::Const(Const::Bool(true)),

        // Return: always False (successful completion)
        IRNode::Return(_) => IRNode::Const(Const::Bool(false)),

        // Direct monadic call (not in a let): check if it aborts
        IRNode::Call { function, args, type_args } if monadic_ids.contains(&function.base) => {
            IRNode::Call {
                function: FunctionID {
                    base: function.base,
                    variant: FunctionVariant::Aborts,
                },
                args,
                type_args,
            }
        }

        // Non-monadic call: check for nested monadic calls in arguments
        IRNode::Call { .. } => {
            let (bindings, _) = extract_aborts_with_bindings(&node, monadic_ids, counter);
            if bindings.is_empty() {
                IRNode::Const(Const::Bool(false))
            } else {
                let abort_conds: Vec<_> = bindings.into_iter().map(|(_, abort, _)| abort).collect();
                or_aborts(abort_conds)
            }
        }

        // Spec nodes: unwrap
        IRNode::Requires(inner) | IRNode::Ensures(inner) => {
            transform_to_aborts_impl(*inner, monadic_ids, counter)
        }

        // Other nodes: check for nested monadic calls
        _ => {
            let (bindings, _) = extract_aborts_with_bindings(&node, monadic_ids, counter);
            if bindings.is_empty() {
                IRNode::Const(Const::Bool(false))
            } else {
                let abort_conds: Vec<_> = bindings.into_iter().map(|(_, abort, _)| abort).collect();
                or_aborts(abort_conds)
            }
        }
    }
}

/// Transform a block's children to abort predicate form.
///
/// The key insight: we need to keep Let bindings for variables that are used
/// in abort conditions. So we process sequentially and wrap the continuation
/// in necessary Let bindings.
fn transform_block_to_aborts_impl(
    children: Vec<IRNode>,
    monadic_ids: &HashSet<usize>,
    counter: &mut usize,
) -> IRNode {
    if children.is_empty() {
        return IRNode::Const(Const::Bool(false));
    }

    // Process children in reverse order, building up the result
    let mut result = IRNode::Const(Const::Bool(false));

    for child in children.into_iter().rev() {
        match child {
            // Let binding: extract all nested monadic calls from the value
            IRNode::Let { pattern, value } => {
                // Extract all abort conditions from the value expression
                let (bindings, pure_value) = extract_aborts_with_bindings(&value, monadic_ids, counter);

                if bindings.is_empty() {
                    // No monadic calls in this value, just wrap the let
                    result = IRNode::Block {
                        children: vec![
                            IRNode::Let {
                                pattern,
                                value: Box::new(pure_value),
                            },
                            result,
                        ],
                    };
                } else {
                    // Build abort chain: if abort1 then True else let tmp1 := pure1 in ...
                    // then at the end: let pattern := expr_with_tmps in <result>
                    let inner = IRNode::Block {
                        children: vec![
                            IRNode::Let {
                                pattern,
                                value: Box::new(pure_value),
                            },
                            result,
                        ],
                    };
                    result = build_abort_chain(bindings, inner);
                }
            }

            // If: transform branches and keep structure
            IRNode::If { cond, then_branch, else_branch } => {
                // Extract aborts from condition first
                let (cond_bindings, pure_cond) = extract_aborts_with_bindings(&cond, monadic_ids, counter);

                let then_aborts = transform_to_aborts_impl(*then_branch, monadic_ids, counter);
                let else_aborts = transform_to_aborts_impl(*else_branch, monadic_ids, counter);

                let then_is_false = matches!(&then_aborts, IRNode::Const(Const::Bool(false)));
                let else_is_false = matches!(&else_aborts, IRNode::Const(Const::Bool(false)));

                let if_aborts = match (then_is_false, else_is_false) {
                    (true, true) => IRNode::Const(Const::Bool(false)),
                    (true, false) => IRNode::If {
                        cond: Box::new(IRNode::UnOp {
                            op: crate::UnOp::Not,
                            operand: Box::new(pure_cond.clone()),
                        }),
                        then_branch: Box::new(else_aborts),
                        else_branch: Box::new(IRNode::Const(Const::Bool(false))),
                    },
                    (false, true) => IRNode::If {
                        cond: Box::new(pure_cond.clone()),
                        then_branch: Box::new(then_aborts),
                        else_branch: Box::new(IRNode::Const(Const::Bool(false))),
                    },
                    (false, false) => IRNode::If {
                        cond: Box::new(pure_cond.clone()),
                        then_branch: Box::new(then_aborts),
                        else_branch: Box::new(else_aborts),
                    },
                };

                // First check condition aborts, then check if body aborts
                let if_with_cond_aborts = if cond_bindings.is_empty() {
                    if_aborts
                } else {
                    build_abort_chain(cond_bindings, if_aborts)
                };

                // Combine with continuation using OR
                result = or_nodes(if_with_cond_aborts, result);
            }

            // While: generate WhileAborts to properly check all iterations
            // Structure: whileAborts OR (let vars := whileLoopPure in continuation)
            IRNode::While { cond, body, vars, invariants } => {
                let body_aborts = transform_to_aborts_impl((*body).clone(), monadic_ids, counter);
                let body_pure = convert_to_pure(&body);

                // Build the continuation that computes post-loop state
                let while_pure = IRNode::While {
                    cond: cond.clone(),
                    body: Box::new(body_pure.clone()),
                    vars: vars.clone(),
                    invariants: invariants.clone(),
                };

                // Wrap continuation in let binding to get post-loop values
                let continuation = if matches!(&result, IRNode::Const(Const::Bool(false))) {
                    result.clone()
                } else {
                    IRNode::Block {
                        children: vec![
                            IRNode::Let {
                                pattern: vars.clone(),
                                value: Box::new(while_pure),
                            },
                            result,
                        ],
                    }
                };

                // Build the full abort predicate
                if matches!(&body_aborts, IRNode::Const(Const::Bool(false))) {
                    // Body never aborts, just check continuation
                    result = continuation;
                } else {
                    let while_aborts = IRNode::WhileAborts {
                        cond,
                        body_aborts: Box::new(body_aborts),
                        body_pure: Box::new(body_pure),
                        vars,
                        invariants,
                    };
                    result = or_nodes(while_aborts, continuation);
                }
            }

            // Abort: True
            IRNode::Abort(_) => {
                result = or_nodes(IRNode::Const(Const::Bool(true)), result);
            }

            // Return: False (successful completion)
            IRNode::Return(_) => {
                // Return doesn't contribute to abort - just continue
            }

            // Direct monadic call (not in let): extract and check
            IRNode::Call { .. } => {
                let (bindings, _) = extract_aborts_with_bindings(&child, monadic_ids, counter);
                if !bindings.is_empty() {
                    // Just need the abort conditions, not the values
                    let abort_conds: Vec<_> = bindings.into_iter().map(|(_, abort, _)| abort).collect();
                    let combined = or_aborts(abort_conds);
                    result = or_nodes(combined, result);
                }
            }

            // Other expressions: check for nested monadic calls
            _ => {
                let (bindings, _) = extract_aborts_with_bindings(&child, monadic_ids, counter);
                if !bindings.is_empty() {
                    let abort_conds: Vec<_> = bindings.into_iter().map(|(_, abort, _)| abort).collect();
                    let combined = or_aborts(abort_conds);
                    result = or_nodes(combined, result);
                }
            }
        }
    }

    result
}

/// Combine two nodes with OR, simplifying if either is False.
fn or_nodes(a: IRNode, b: IRNode) -> IRNode {
    let a_is_false = matches!(&a, IRNode::Const(Const::Bool(false)));
    let b_is_false = matches!(&b, IRNode::Const(Const::Bool(false)));

    match (a_is_false, b_is_false) {
        (true, true) => IRNode::Const(Const::Bool(false)),
        (true, false) => b,
        (false, true) => a,
        (false, false) => IRNode::BinOp {
            op: crate::BinOp::Or,
            lhs: Box::new(a),
            rhs: Box::new(b),
        },
    }
}

/// Extract abort conditions from an expression, recursively checking all sub-expressions.
/// This handles nested monadic calls like `f(g.monadic(x), y)`.
///
/// Returns a list of (abort_condition, pure_binding) pairs that need to be checked
/// in sequence before the expression can be safely evaluated.
fn extract_aborts_with_bindings(
    node: &IRNode,
    monadic_ids: &HashSet<usize>,
    counter: &mut usize,
) -> (Vec<(String, IRNode, IRNode)>, IRNode) {
    match node {
        // Monadic call: extract abort check and pure replacement
        // First, recursively extract aborts from arguments
        IRNode::Call { function, args, type_args } if monadic_ids.contains(&function.base) => {
            let mut all_bindings = Vec::new();
            let mut new_args = Vec::new();

            // Recursively process arguments - they might contain nested monadic calls
            for arg in args {
                let (bindings, new_arg) = extract_aborts_with_bindings(arg, monadic_ids, counter);
                all_bindings.extend(bindings);
                new_args.push(new_arg);
            }

            let var_name = format!("$abort_tmp_{}", *counter);
            *counter += 1;

            // Use the transformed arguments (with temp vars) for both abort and pure calls
            let abort_call = IRNode::Call {
                function: FunctionID {
                    base: function.base,
                    variant: FunctionVariant::Aborts,
                },
                args: new_args.clone(),
                type_args: type_args.clone(),
            };

            let pure_call = IRNode::Call {
                function: FunctionID {
                    base: function.base,
                    variant: FunctionVariant::Pure,
                },
                args: new_args,
                type_args: type_args.clone(),
            };

            // Add this call's binding after the argument bindings
            all_bindings.push((var_name.clone(), abort_call, pure_call));

            (all_bindings, IRNode::Var(var_name))
        }

        // Non-monadic call: recursively check arguments
        IRNode::Call { function, args, type_args } => {
            let mut all_bindings = Vec::new();
            let mut new_args = Vec::new();

            for arg in args {
                let (bindings, new_arg) = extract_aborts_with_bindings(arg, monadic_ids, counter);
                all_bindings.extend(bindings);
                new_args.push(new_arg);
            }

            let new_node = IRNode::Call {
                function: *function,
                args: new_args,
                type_args: type_args.clone(),
            };

            (all_bindings, new_node)
        }

        // Binary operations: check both operands
        IRNode::BinOp { op, lhs, rhs } => {
            let (lhs_bindings, new_lhs) = extract_aborts_with_bindings(lhs, monadic_ids, counter);
            let (rhs_bindings, new_rhs) = extract_aborts_with_bindings(rhs, monadic_ids, counter);

            let mut all_bindings = lhs_bindings;
            all_bindings.extend(rhs_bindings);

            let new_node = IRNode::BinOp {
                op: *op,
                lhs: Box::new(new_lhs),
                rhs: Box::new(new_rhs),
            };

            (all_bindings, new_node)
        }

        // Unary operations: check operand
        IRNode::UnOp { op, operand } => {
            let (bindings, new_operand) = extract_aborts_with_bindings(operand, monadic_ids, counter);

            let new_node = IRNode::UnOp {
                op: *op,
                operand: Box::new(new_operand),
            };

            (bindings, new_node)
        }

        // If expression: only extract from condition
        IRNode::If { cond, then_branch, else_branch } => {
            // Only extract from condition (always evaluated)
            // Branches are conditionally evaluated - handled properly in transform_to_aborts_impl
            let (cond_bindings, new_cond) = extract_aborts_with_bindings(cond, monadic_ids, counter);

            let new_node = IRNode::If {
                cond: Box::new(new_cond),
                then_branch: then_branch.clone(),
                else_branch: else_branch.clone(),
            };

            (cond_bindings, new_node)
        }

        // Tuple: check all elements
        IRNode::Tuple(elems) => {
            let mut all_bindings = Vec::new();
            let mut new_elems = Vec::new();

            for elem in elems {
                let (bindings, new_elem) = extract_aborts_with_bindings(elem, monadic_ids, counter);
                all_bindings.extend(bindings);
                new_elems.push(new_elem);
            }

            (all_bindings, IRNode::Tuple(new_elems))
        }

        // Field access: check base
        IRNode::Field { base, struct_id, field_index } => {
            let (bindings, new_base) = extract_aborts_with_bindings(base, monadic_ids, counter);

            let new_node = IRNode::Field {
                base: Box::new(new_base),
                struct_id: *struct_id,
                field_index: *field_index,
            };

            (bindings, new_node)
        }

        // Pack: check all field values
        IRNode::Pack { struct_id, type_args, fields } => {
            let mut all_bindings = Vec::new();
            let mut new_fields = Vec::new();

            for field in fields {
                let (bindings, new_field) = extract_aborts_with_bindings(field, monadic_ids, counter);
                all_bindings.extend(bindings);
                new_fields.push(new_field);
            }

            let new_node = IRNode::Pack {
                struct_id: *struct_id,
                type_args: type_args.clone(),
                fields: new_fields,
            };

            (all_bindings, new_node)
        }

        // Abort: this is an abort condition itself
        IRNode::Abort(_) => {
            // Return True as abort condition, unit as replacement
            let var_name = format!("$abort_tmp_{}", *counter);
            *counter += 1;
            (vec![(var_name.clone(), IRNode::Const(Const::Bool(true)), IRNode::unit())], IRNode::Var(var_name))
        }

        // Leaf nodes: no aborts
        IRNode::Var(_) | IRNode::Const(_) => {
            (vec![], node.clone())
        }

        // Other nodes: clone as-is (conservative)
        _ => (vec![], node.clone()),
    }
}

/// Build a chain of abort checks from bindings.
/// Each binding is (var_name, abort_condition, pure_value).
/// Returns: if abort1 then True else let var1 := pure1 in if abort2 then True else ...
fn build_abort_chain(
    bindings: Vec<(String, IRNode, IRNode)>,
    continuation: IRNode,
) -> IRNode {
    bindings.into_iter().rev().fold(continuation, |cont, (var_name, abort_cond, pure_val)| {
        // Skip if abort condition is always False
        if matches!(&abort_cond, IRNode::Const(Const::Bool(false))) {
            IRNode::Block {
                children: vec![
                    IRNode::Let {
                        pattern: vec![var_name],
                        value: Box::new(pure_val),
                    },
                    cont,
                ],
            }
        } else {
            IRNode::If {
                cond: Box::new(abort_cond),
                then_branch: Box::new(IRNode::Const(Const::Bool(true))),
                else_branch: Box::new(IRNode::Block {
                    children: vec![
                        IRNode::Let {
                            pattern: vec![var_name],
                            value: Box::new(pure_val),
                        },
                        cont,
                    ],
                }),
            }
        }
    })
}

/// Combine multiple abort conditions with OR, filtering out False.
fn or_aborts(aborts: Vec<IRNode>) -> IRNode {
    let non_false: Vec<_> = aborts
        .into_iter()
        .filter(|n| !matches!(n, IRNode::Const(Const::Bool(false))))
        .collect();

    match non_false.len() {
        0 => IRNode::Const(Const::Bool(false)),
        1 => non_false.into_iter().next().unwrap(),
        _ => non_false.into_iter().reduce(|acc, n| {
            IRNode::BinOp {
                op: crate::BinOp::Or,
                lhs: Box::new(acc),
                rhs: Box::new(n),
            }
        }).unwrap(),
    }
}

/// Convert monadic IR to pure (non-monadic) version.
/// - Simplify Ifs where branches always abort
/// - Filter out Abort nodes
/// - Unwrap Returns
pub fn convert_to_pure(node: &IRNode) -> IRNode {
    // First simplify If nodes where branches always abort
    let node = simplify_aborting_ifs(node.clone());

    // Remove Abort nodes and unwrap Returns
    node.map(&mut |n| match n {
        // Filter Abort nodes from Block children
        IRNode::Block { children } => {
            let filtered: Vec<_> = children
                .into_iter()
                .filter(|c| !matches!(c, IRNode::Abort(_)))
                .collect();
            IRNode::Block { children: filtered }
        }
        // Abort nodes that escape to expression position become unit
        IRNode::Abort(_) => IRNode::unit(),
        // Unwrap Returns
        IRNode::Return(vals) => {
            if vals.len() == 1 {
                vals.into_iter().next().unwrap()
            } else {
                IRNode::Tuple(vals)
            }
        }
        // Spec nodes shouldn't appear in runtime functions, unwrap them
        IRNode::Requires(inner) | IRNode::Ensures(inner) => *inner,
        other => other,
    })
}

/// Simplify If nodes where branches always abort.
/// - If both branches abort, replace with unit (unreachable)
/// - If only then branch aborts, keep else branch
/// - If only else branch aborts, keep then branch
///
/// We recursively simplify until no more changes occur, because
/// inner simplifications may cause outer ifs to become simplifiable.
fn simplify_aborting_ifs(node: IRNode) -> IRNode {
    let original = node.clone();
    let simplified = node.map(&mut |n| match n {
        IRNode::If {
            cond,
            then_branch,
            else_branch,
        } => {
            let then_always_aborts = then_branch.always_aborts();
            let else_always_aborts = else_branch.always_aborts();

            if then_always_aborts && else_always_aborts {
                IRNode::unit()
            } else if then_always_aborts {
                *else_branch
            } else if else_always_aborts {
                *then_branch
            } else {
                IRNode::If {
                    cond,
                    then_branch,
                    else_branch,
                }
            }
        }
        other => other,
    });

    // Continue simplifying until fixpoint (handles newly exposed abort patterns)
    if simplified == original {
        simplified
    } else {
        simplify_aborting_ifs(simplified)
    }
}
