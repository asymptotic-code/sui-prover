// Copyright (c) Asymptotic Labs
// SPDX-License-Identifier: Apache-2.0

//! Z3-based elimination of impossible abort conditions
//!
//! This pass analyzes abort predicates and removes abort checks that are
//! provably impossible given the path constraints (e.g., from if conditions).
//!
//! For example:
//! ```
//! if x > 10 then
//!   if x < 5 then True else False  -- x < 5 is impossible, eliminate
//! ```

use crate::data::functions::FunctionVariant;
use crate::data::Program;
use crate::smt::{new_context, SmtContext};
use crate::{Const, FunctionID, IRNode};
use z3::ast::Bool;
use z3::{SatResult, Solver};

/// Eliminate provably-impossible abort conditions from abort predicates.
///
/// This runs on all `.aborts` functions and simplifies them by removing
/// abort checks that are unsatisfiable given the accumulated path constraints.
pub fn eliminate_impossible_aborts(program: &mut Program) {
    let ctx = new_context();

    // Collect all .aborts function IDs
    let aborts_ids: Vec<FunctionID> = program
        .functions
        .iter()
        .filter(|(id, _)| id.variant == FunctionVariant::Aborts)
        .map(|(id, _)| id)
        .collect();

    for func_id in aborts_ids {
        let func = program.functions.get(&func_id);
        let mut smt_ctx = SmtContext::with_program(&ctx, program);

        // Bind parameters as symbolic values
        for param in &func.signature.parameters {
            if let Some(var) = smt_ctx.fresh_for_type(&param.name, &param.param_type) {
                smt_ctx.bind_var(param.name.clone(), var);
            }
        }

        // Eliminate impossible aborts with empty initial constraints
        let simplified = eliminate_in_node(&func.body, &mut smt_ctx, &[]);

        // Update function body
        let func_mut = program.functions.get_mut(func_id);
        func_mut.body = simplified;
    }
}

/// Recursively eliminate impossible abort checks in an IR node.
///
/// `path_constraints` are Bool expressions that must be true on this path.
fn eliminate_in_node<'ctx>(
    node: &IRNode,
    smt_ctx: &mut SmtContext<'ctx, '_>,
    path_constraints: &[Bool<'ctx>],
) -> IRNode {
    match node {
        // If with abort check: `if <abort_cond> then True else <continuation>`
        // This is the key pattern generated by build_abort_chain
        IRNode::If { cond, then_branch, else_branch }
            if matches!(**then_branch, IRNode::Const(Const::Bool(true))) =>
        {
            // Check if the abort condition is satisfiable under path constraints
            if let Some(cond_z3) = smt_ctx.translate_to_bool(cond) {
                if is_unsat_with_constraints(smt_ctx.ctx, &cond_z3, path_constraints) {
                    // This abort can never happen - skip to else branch
                    return eliminate_in_node(else_branch, smt_ctx, path_constraints);
                }

                // Can't eliminate - process else branch with negated condition as constraint
                let mut new_constraints = path_constraints.to_vec();
                new_constraints.push(cond_z3.not());
                let else_simplified = eliminate_in_node(else_branch, smt_ctx, &new_constraints);

                return IRNode::If {
                    cond: cond.clone(),
                    then_branch: then_branch.clone(),
                    else_branch: Box::new(else_simplified),
                };
            }

            // Couldn't translate condition - just recurse without constraints
            let else_simplified = eliminate_in_node(else_branch, smt_ctx, path_constraints);
            IRNode::If {
                cond: cond.clone(),
                then_branch: then_branch.clone(),
                else_branch: Box::new(else_simplified),
            }
        }

        // Regular If: process both branches with appropriate constraints
        IRNode::If { cond, then_branch, else_branch } => {
            let (then_constraints, else_constraints) = if let Some(cond_z3) = smt_ctx.translate_to_bool(cond) {
                let mut then_c = path_constraints.to_vec();
                then_c.push(cond_z3.clone());

                let mut else_c = path_constraints.to_vec();
                else_c.push(cond_z3.not());

                (then_c, else_c)
            } else {
                (path_constraints.to_vec(), path_constraints.to_vec())
            };

            let then_simplified = eliminate_in_node(then_branch, smt_ctx, &then_constraints);
            let else_simplified = eliminate_in_node(else_branch, smt_ctx, &else_constraints);

            // Simplify if both branches are the same constant
            if let (IRNode::Const(Const::Bool(a)), IRNode::Const(Const::Bool(b))) =
                (&then_simplified, &else_simplified)
            {
                if a == b {
                    return IRNode::Const(Const::Bool(*a));
                }
            }

            IRNode::If {
                cond: cond.clone(),
                then_branch: Box::new(then_simplified),
                else_branch: Box::new(else_simplified),
            }
        }

        // Block: process children sequentially, preserving the final Bool(false) continuation
        IRNode::Block { children } => {
            let mut simplified_children = Vec::new();
            for child in children {
                simplified_children.push(eliminate_in_node(child, smt_ctx, path_constraints));
            }

            // Don't filter out the final element - it's the continuation/return value of the block
            // Only filter intermediate Const(false) which don't contribute to abort
            let filtered: Vec<_> = simplified_children
                .into_iter()
                .enumerate()
                .filter(|(i, c)| {
                    // Keep the last element always
                    if *i == children.len() - 1 {
                        return true;
                    }
                    // Filter out intermediate Const(false) which don't contribute
                    !matches!(c, IRNode::Const(Const::Bool(false)))
                })
                .map(|(_, c)| c)
                .collect();

            match filtered.len() {
                0 => IRNode::Const(Const::Bool(false)),
                1 => filtered.into_iter().next().unwrap(),
                _ => IRNode::Block { children: filtered },
            }
        }

        // BinOp Or: both operands can contribute to abort
        IRNode::BinOp { op: crate::BinOp::Or, lhs, rhs } => {
            let lhs_simplified = eliminate_in_node(lhs, smt_ctx, path_constraints);
            let rhs_simplified = eliminate_in_node(rhs, smt_ctx, path_constraints);

            // Simplify Or
            match (&lhs_simplified, &rhs_simplified) {
                (IRNode::Const(Const::Bool(false)), _) => rhs_simplified,
                (_, IRNode::Const(Const::Bool(false))) => lhs_simplified,
                (IRNode::Const(Const::Bool(true)), _) => IRNode::Const(Const::Bool(true)),
                (_, IRNode::Const(Const::Bool(true))) => IRNode::Const(Const::Bool(true)),
                _ => IRNode::BinOp {
                    op: crate::BinOp::Or,
                    lhs: Box::new(lhs_simplified),
                    rhs: Box::new(rhs_simplified),
                },
            }
        }

        // BinOp And: for completeness
        IRNode::BinOp { op: crate::BinOp::And, lhs, rhs } => {
            let lhs_simplified = eliminate_in_node(lhs, smt_ctx, path_constraints);
            let rhs_simplified = eliminate_in_node(rhs, smt_ctx, path_constraints);

            match (&lhs_simplified, &rhs_simplified) {
                (IRNode::Const(Const::Bool(true)), _) => rhs_simplified,
                (_, IRNode::Const(Const::Bool(true))) => lhs_simplified,
                (IRNode::Const(Const::Bool(false)), _) => IRNode::Const(Const::Bool(false)),
                (_, IRNode::Const(Const::Bool(false))) => IRNode::Const(Const::Bool(false)),
                _ => IRNode::BinOp {
                    op: crate::BinOp::And,
                    lhs: Box::new(lhs_simplified),
                    rhs: Box::new(rhs_simplified),
                },
            }
        }

        // Let: translate the whole Let node to bind variables in SMT context, then recurse
        IRNode::Let { pattern, value } => {
            // Translate the Let node to bind variables in SMT context
            // This is needed so subsequent abort checks can reference these variables
            let _ = smt_ctx.translate(node);

            let simplified_value = eliminate_in_node(value, smt_ctx, path_constraints);
            IRNode::Let {
                pattern: pattern.clone(),
                value: Box::new(simplified_value),
            }
        }

        // WhileAborts: use invariants as constraints, then recurse into body_aborts
        IRNode::WhileAborts { cond, body_aborts, body_pure, vars, invariants } => {
            // Add invariants as path constraints - they hold at every iteration
            let mut loop_constraints = path_constraints.to_vec();
            for inv in invariants {
                if let Some(inv_z3) = smt_ctx.translate_to_bool(inv) {
                    loop_constraints.push(inv_z3);
                }
            }

            let simplified_body_aborts = eliminate_in_node(body_aborts, smt_ctx, &loop_constraints);

            // If body never aborts, return False
            if matches!(&simplified_body_aborts, IRNode::Const(Const::Bool(false))) {
                return IRNode::Const(Const::Bool(false));
            }

            IRNode::WhileAborts {
                cond: cond.clone(),
                body_aborts: Box::new(simplified_body_aborts),
                body_pure: body_pure.clone(),
                vars: vars.clone(),
                invariants: invariants.clone(),
            }
        }

        // Other nodes: return as-is
        _ => node.clone(),
    }
}

/// Check if a condition is unsatisfiable given path constraints.
fn is_unsat_with_constraints<'ctx>(
    ctx: &'ctx z3::Context,
    cond: &Bool<'ctx>,
    constraints: &[Bool<'ctx>],
) -> bool {
    let solver = Solver::new(ctx);

    // Assert all path constraints
    for c in constraints {
        solver.assert(c);
    }

    // Assert the condition we're checking
    solver.assert(cond);

    // Check satisfiability
    matches!(solver.check(), SatResult::Unsat)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_simple_elimination() {
        // Test: if x > 10 then (if x < 5 then True else False) else False
        // The x < 5 branch should be eliminated since x > 10 implies x >= 5
        // This is tested through the program infrastructure in integration tests
    }
}
