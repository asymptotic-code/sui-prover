// Copyright (c) Asymptotic Labs
// SPDX-License-Identifier: Apache-2.0

//! Renders complete TheoremProgram to Lean files

use intermediate_theorem_format::TheoremProgram;
use super::function_renderer::FunctionRenderer;
use super::struct_renderer::StructRenderer;
use super::lean_writer::LeanWriter;
use std::fs;
use std::path::Path;

pub struct ProgramRenderer {
    function_renderer: FunctionRenderer,
    struct_renderer: StructRenderer,
}

impl ProgramRenderer {
    pub fn new() -> Self {
        Self {
            function_renderer: FunctionRenderer::new(),
            struct_renderer: StructRenderer::new(),
        }
    }


    /// Render the entire program to a Lean file
    pub fn render_to_file(&self, program: &TheoremProgram, output_path: &Path) -> anyhow::Result<()> {
        let mut output = String::new();

        // Header
        output.push_str("-- Generated by sui-prover\n");
        output.push_str("-- Simple direct translation from TheoremIR\n\n");

        // Render all functions
        for func in program.functions.values() {
            let writer = LeanWriter::new(&program.name_manager);
            println!("RENDERER: Rendering function: {} in module {}", func.name, func.module_id);
            self.function_renderer.render(func, program, &writer);
            let result = writer.extract_result();
            println!("RENDERER: Function {} rendered ({} chars)", func.name, result.len());
            output.push_str(&result);
            output.push_str("\n");
        }

        // Write to file
        if let Some(parent) = output_path.parent() {
            fs::create_dir_all(parent)?;
        }
        fs::write(output_path, output)?;

        Ok(())
    }

    /// Render program to directory structure (organized by module hierarchy)
    pub fn render_to_directory(&self, program: &TheoremProgram, output_dir: &Path, prelude_imports: &[String]) -> anyhow::Result<()> {
        fs::create_dir_all(output_dir)?;

        println!("RENDERER: Copying native packages...");
        // Copy native package implementations from lemmas directory
        self.copy_native_packages(program, output_dir)?;
        println!("RENDERER: Native packages copied.");

        println!("RENDERER: Rendering {} modules...", program.modules.len());
        // Render each module
        for (&module_id, module) in &program.modules {
            println!("RENDERER: Rendering module: {}", module.name);
            let mut module_output = String::new();

            module_output.push_str(&format!("-- Module: {}\n\n", module.name));

            // Import Prelude modules (dynamically discovered from actual files)
            for prelude_import in prelude_imports {
                module_output.push_str(&format!("import {}\n", prelude_import));
            }

            // Add imports for other modules that this module depends on
            // Use pre-computed imports from IR
            for &required_module_id in &module.required_imports {
                if let Some(required_module) = program.modules.get(&required_module_id) {
                    let import_path = self.module_to_import_path(required_module);
                    module_output.push_str(&format!("import {}\n", import_path));
                }
            }

            // If this module has native functions AND a natives file exists, import it
            // (except for MoveStdlib which handles natives differently)
            let has_native_functions = program.functions.values()
                .any(|f| f.module_id == module_id && f.is_native);
            if has_native_functions && &module.package_name != "MoveStdlib" {
                let namespace_name = Self::capitalize_first(&module.name);
                // Check if natives file actually exists before importing it
                // Note: output_dir is the Impls directory
                let natives_path = output_dir.join(&module.package_name).join(format!("{}Natives.lean", namespace_name));
                if natives_path.exists() {
                    module_output.push_str(&format!("import Impls.{}.{}Natives\n", module.package_name, namespace_name));
                }
            }

            module_output.push('\n');

            // Capitalize module name for Lean namespace
            // Avoid conflicts with Lean built-in types/modules
            let namespace_name = Self::module_name_to_namespace(&module.name);

            // Open namespace for this module
            module_output.push_str(&format!("namespace {}\n\n", namespace_name));

            // Render all structs in this module FIRST (before functions that use them)
            // Structs are already topologically sorted globally by DependencyOrderPass
            // Filter to only structs in this module, maintaining global sort order
            for (_, struct_def) in &program.structs {
                if struct_def.module_id == module_id {
                    let writer = LeanWriter::with_module(&program.name_manager, namespace_name.clone());
                    self.struct_renderer.render(struct_def, &writer);
                    module_output.push_str(&writer.extract_result());
                    module_output.push_str("\n");
                }
            }

            // Render all functions in this module
            // Native functions are rendered with axiom/sorry stubs by the function renderer
            // Functions are already globally sorted by DependencyOrderPass
            let mut rendered_functions = std::collections::HashSet::new();
            for (_, func) in &program.functions {
                if func.module_id != module_id {
                    continue;
                }

                // Skip if already rendered (shouldn't happen, but defensive check)
                // Use function ID for deduplication since IDs are globally unique
                if rendered_functions.contains(&func.id) {
                    continue;
                }

                // Skip native functions - they should be provided by lemmas files
                if func.is_native {
                    continue;
                }

                println!("RENDERER: Rendering function: {} in module {}", func.name, module.name);
                let writer = LeanWriter::with_module(&program.name_manager, namespace_name.clone());
                self.function_renderer.render(func, program, &writer);
                let rendered = writer.extract_result();
                println!("RENDERER: Function {} rendered ({} chars)", func.name, rendered.len());
                // Only add non-empty functions to avoid malformed output
                if !rendered.trim().is_empty() {
                    module_output.push_str(&rendered);
                    module_output.push_str("\n");
                }
                rendered_functions.insert(func.id);
            }

            // Ensure there's a blank line before closing namespace
            if !module_output.ends_with("\n\n") && !module_output.ends_with("namespace") {
                module_output.push('\n');
            }

            // Close namespace
            module_output.push_str(&format!("end {}\n", namespace_name));

            // Get the module file path from stored data
            let module_path = self.get_module_file_path_from_module(module);
            let module_file = output_dir.join(&module_path);

            // Create parent directories if needed
            if let Some(parent) = module_file.parent() {
                fs::create_dir_all(parent)?;
            }

            fs::write(module_file, module_output)?;
        }

        Ok(())
    }

    /// Get module file path from TheoremModule data
    fn get_module_file_path_from_module(&self, module: &intermediate_theorem_format::TheoremModule) -> String {
        let namespace = Self::module_name_to_namespace(&module.name);
        format!("{}/{}.lean", module.package_name, namespace)
    }

    /// Convert a module to its Lean import path
    fn module_to_import_path(
        &self,
        module: &intermediate_theorem_format::TheoremModule,
    ) -> String {
        let namespace = Self::module_name_to_namespace(&module.name);
        format!("Impls.{}.{}", module.package_name, namespace)
    }

    /// Convert a Move module name to a Lean namespace name (avoiding built-in conflicts)
    fn module_name_to_namespace(module_name: &str) -> String {
        match module_name {
            "vector" => "MoveVector".to_string(),
            "option" => "MoveOption".to_string(),
            _ => Self::capitalize_first(module_name),
        }
    }

    /// Capitalize the first letter of a string (for Lean naming conventions)
    fn capitalize_first(s: &str) -> String {
        let mut chars = s.chars();
        match chars.next() {
            None => String::new(),
            Some(first) => {
                let mut result = first.to_uppercase().collect::<String>();
                result.push_str(chars.as_str());
                result
            }
        }
    }

    /// Copy native package implementations from lemmas directory to output
    fn copy_native_packages(&self, program: &TheoremProgram, output_dir: &Path) -> anyhow::Result<()> {
        use std::collections::HashSet;

        // Get the path to the lemmas directory (in the crate)
        let lemmas_dir = Path::new(env!("CARGO_MANIFEST_DIR")).join("lemmas");

        // Track which modules we've copied
        let mut copied_modules = HashSet::new();

        // For each module in the program
        for module in program.modules.values() {
            // Check if this module has any native functions
            let has_native_functions = program.functions.values()
                .any(|f| f.module_id == module.id && f.is_native);

            if !has_native_functions {
                continue;
            }

            // Avoid duplicates
            let module_key = format!("{}::{}", module.package_name, module.name);
            if copied_modules.contains(&module_key) {
                continue;
            }

            // Map module to its lemma file
            let lemma_file = self.get_native_lemma_path(&module.package_name, &module.name);
            let source_path = lemmas_dir.join(&lemma_file);

            if !source_path.exists() {
                // No native implementation available - this is OK, module will be empty
                continue;
            }

            // Determine destination path in output
            let namespace = Self::module_name_to_namespace(&module.name);
            // MoveStdlib goes to package root, all others go to Package/
            // Native files use Natives suffix to avoid overwriting generated files
            // Note: output_dir is already the Impls directory
            let dest_path = if &module.package_name == "MoveStdlib" {
                output_dir.join(&module.package_name).join(format!("{}.lean", namespace))
            } else {
                output_dir.join(&module.package_name).join(format!("{}Natives.lean", namespace))
            };

            // Create parent directory
            if let Some(parent) = dest_path.parent() {
                fs::create_dir_all(parent)?;
            }

            // Copy the file
            fs::copy(&source_path, &dest_path)?;

            copied_modules.insert(module_key);
        }

        Ok(())
    }

    /// Get the path to a native lemma file relative to lemmas directory
    fn get_native_lemma_path(&self, package_name: &str, module_name: &str) -> String {
        match package_name {
            "MoveStdlib" => {
                // Map module names to their Prelude files
                match module_name {
                    "vector" => "Prelude/Vector.lean".to_string(),
                    _ => format!("Prelude/{}.lean", Self::capitalize_first(module_name)),
                }
            }
            // All other packages use the natives/ directory structure
            _ => format!("natives/{}/{}.lean", package_name, Self::capitalize_first(module_name)),
        }
    }
}
