// Copyright (c) Asymptotic Labs
// SPDX-License-Identifier: Apache-2.0

//! Renders complete TheoremProgram to Lean files

use intermediate_theorem_format::TheoremProgram;
use super::function_renderer::FunctionRenderer;
use super::struct_renderer::StructRenderer;
use super::lean_writer::LeanWriter;
use std::fs;
use std::path::Path;

pub struct ProgramRenderer {
    function_renderer: FunctionRenderer,
    struct_renderer: StructRenderer,
}

impl ProgramRenderer {
    pub fn new() -> Self {
        Self {
            function_renderer: FunctionRenderer::new(),
            struct_renderer: StructRenderer::new(),
        }
    }


    /// Render the entire program to a Lean file
    pub fn render_to_file(&self, program: &TheoremProgram, output_path: &Path) -> anyhow::Result<()> {
        let mut output = String::new();

        // Header
        output.push_str("-- Generated by sui-prover\n");
        output.push_str("-- Simple direct translation from TheoremIR\n\n");

        // Render all functions
        for func in program.functions.values() {
            let writer = LeanWriter::new(&program.name_manager);
            self.function_renderer.render(func, program, &writer);
            output.push_str(&writer.extract_result());
            output.push_str("\n");
        }

        // Write to file
        fs::create_dir_all(output_path.parent().unwrap())?;
        fs::write(output_path, output)?;

        Ok(())
    }

    /// Render program to directory structure (organized by module hierarchy)
    pub fn render_to_directory(&self, program: &TheoremProgram, output_dir: &Path, prelude_imports: &[String]) -> anyhow::Result<()> {
        fs::create_dir_all(output_dir)?;

        // Render each module
        for (&module_id, module) in &program.modules {
            let mut module_output = String::new();

            module_output.push_str(&format!("-- Module: {}\n\n", module.name));

            // Import Prelude modules (dynamically discovered from actual files)
            for prelude_import in prelude_imports {
                module_output.push_str(&format!("import {}\n", prelude_import));
            }

            // Add imports for other modules that this module depends on
            let module_imports = self.collect_module_imports(program, module_id);
            for import in module_imports {
                module_output.push_str(&format!("import {}\n", import));
            }
            module_output.push('\n');

            // Extract module short name and capitalize for namespace
            let module_short_name = module.name.split("::").last().unwrap_or(&module.name);
            let mut namespace_name = self.capitalize_first(module_short_name);

            // Avoid conflicts with Lean built-in types/modules
            // Lean has a built-in Vector type, so rename it to avoid conflicts
            if namespace_name == "Vector" {
                namespace_name = "MoveVector".to_string();
            }

            // Open namespace for this module
            module_output.push_str(&format!("namespace {}\n\n", namespace_name));

            // Render all structs in this module FIRST (before functions that use them)
            // Structs are already topologically sorted globally by DependencyOrderPass
            // Filter to only structs in this module, maintaining global sort order
            for (_, struct_def) in &program.structs {
                if struct_def.module_id == module_id {
                    let writer = LeanWriter::with_module(&program.name_manager, namespace_name.clone());
                    self.struct_renderer.render(struct_def, &writer);
                    module_output.push_str(&writer.extract_result());
                    module_output.push_str("\n");
                }
            }

            // Render all functions in this module
            // Skip functions that have both native implementations AND bytecode bodies
            // The native impl takes precedence
            // Also skip functions that were not translated (have empty bodies)
            // Functions are already globally sorted by DependencyOrderPass
            let mut rendered_functions = std::collections::HashSet::new();
            for (_, func) in &program.functions {
                if func.module_id != module_id {
                    continue;
                }

                // Skip if already rendered (shouldn't happen, but defensive check)
                if rendered_functions.contains(&func.name) {
                    continue;
                }

                // Skip functions that were not translated (have empty body)
                // Empty body is Statement::Sequence(vec![])
                use intermediate_theorem_format::Statement;
                let is_empty = matches!(func.body, Statement::Sequence(ref stmts) if stmts.is_empty());
                if is_empty {
                    continue;
                }

                let writer = LeanWriter::with_module(&program.name_manager, namespace_name.clone());
                self.function_renderer.render(func, program, &writer);
                let rendered = writer.extract_result();
                // Only add non-empty functions to avoid malformed output
                if !rendered.trim().is_empty() {
                    module_output.push_str(&rendered);
                    module_output.push_str("\n");
                }
                rendered_functions.insert(func.name.clone());
            }

            // Ensure there's a blank line before closing namespace
            if !module_output.ends_with("\n\n") && !module_output.ends_with("namespace") {
                module_output.push('\n');
            }

            // Close namespace
            module_output.push_str(&format!("end {}\n", namespace_name));

            // Get the module file path from stored data
            let module_path = self.get_module_file_path_from_module(module);
            let module_file = output_dir.join(&module_path);

            // Create parent directories if needed
            if let Some(parent) = module_file.parent() {
                fs::create_dir_all(parent)?;
            }

            fs::write(module_file, module_output)?;
        }

        Ok(())
    }

    /// Get module file path from TheoremModule data
    fn get_module_file_path_from_module(&self, module: &intermediate_theorem_format::TheoremModule) -> String {
        let capitalized_name = self.capitalize_first(&module.simple_name);
        let capitalized_package = self.capitalize_first(&module.package_name);
        format!("{}/{}.lean", capitalized_package, capitalized_name)
    }

    fn capitalize_first(&self, s: &str) -> String {
        let mut chars = s.chars();
        match chars.next() {
            None => String::new(),
            Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
        }
    }

    /// Collect all module imports needed for this module based on type dependencies
    fn collect_module_imports(
        &self,
        program: &TheoremProgram,
        module_id: intermediate_theorem_format::TheoremModuleID,
    ) -> Vec<String> {
        use std::collections::BTreeSet;
        use intermediate_theorem_format::TheoremType;

        let mut required_modules = BTreeSet::new();

        // Helper to extract struct IDs from types
        fn extract_struct_ids(ty: &TheoremType, struct_ids: &mut BTreeSet<usize>) {
            match ty {
                TheoremType::Struct { struct_id, type_args } => {
                    struct_ids.insert(*struct_id);
                    for arg in type_args {
                        extract_struct_ids(arg, struct_ids);
                    }
                }
                TheoremType::Reference(inner) | TheoremType::MutableReference(inner) => {
                    extract_struct_ids(inner, struct_ids);
                }
                TheoremType::Vector(inner) => {
                    extract_struct_ids(inner, struct_ids);
                }
                TheoremType::Tuple(types) => {
                    for ty in types {
                        extract_struct_ids(ty, struct_ids);
                    }
                }
                TheoremType::ProgramState(inner) => {
                    extract_struct_ids(inner, struct_ids);
                }
                _ => {}
            }
        }

        // Collect struct IDs from struct fields in this module
        let mut used_struct_ids = BTreeSet::new();
        for (_, struct_def) in &program.structs {
            if struct_def.module_id == module_id {
                for field in &struct_def.fields {
                    extract_struct_ids(&field.field_type, &mut used_struct_ids);
                }
            }
        }

        // Convert struct IDs to module IDs using centralized module_id field
        let mut used_module_ids = BTreeSet::new();
        for struct_id in &used_struct_ids {
            if let Some(struct_def) = program.structs.get(struct_id) {
                used_module_ids.insert(struct_def.module_id);
            }
        }

        // Collect struct IDs from function signatures and calls
        let mut called_function_ids = BTreeSet::new();
        for (_, func) in &program.functions {
            if func.module_id == module_id {
                // Check parameters
                for param in &func.signature.parameters {
                    extract_struct_ids(&param.param_type, &mut used_struct_ids);
                }
                // Check return types
                for ret_ty in &func.signature.return_types {
                    extract_struct_ids(ret_ty, &mut used_struct_ids);
                }
                // Collect function calls from the function body
                self.extract_function_calls(&func.body, &mut called_function_ids);
            }
        }

        // Convert collected struct IDs to module IDs
        for struct_id in &used_struct_ids {
            if let Some(struct_def) = program.structs.get(struct_id) {
                used_module_ids.insert(struct_def.module_id);
            }
        }

        // Generate import paths for used modules (exclude self)
        for used_module_id in &used_module_ids {
            if *used_module_id != module_id {
                if let Some(other_module) = program.modules.get(used_module_id) {
                    let import_path = self.module_to_import_path(other_module);
                    required_modules.insert(import_path);
                }
            }
        }

        // Find modules that define the functions we call
        for called_func_id in called_function_ids {
            if let Some(called_func) = program.functions.get(&called_func_id) {
                // Use centralized module_id field - O(1) lookup!
                if called_func.module_id != module_id {
                    if let Some(other_module) = program.modules.get(&called_func.module_id) {
                        let import_path = self.module_to_import_path(other_module);
                        required_modules.insert(import_path);
                    }
                }
            }
        }

        required_modules.into_iter().collect()
    }

    /// Extract all function calls from a statement recursively using the visitor API
    fn extract_function_calls(
        &self,
        stmt: &intermediate_theorem_format::Statement,
        calls: &mut std::collections::BTreeSet<usize>,
    ) {
        // Use the built-in visitor API from Statement
        for func_id in stmt.calls() {
            calls.insert(func_id);
        }
    }

    /// Convert a module to its Lean import path
    fn module_to_import_path(
        &self,
        module: &intermediate_theorem_format::TheoremModule,
    ) -> String {
        let capitalized_name = self.capitalize_first(&module.simple_name);
        let capitalized_package = self.capitalize_first(&module.package_name);
        format!("Impls.{}.{}", capitalized_package, capitalized_name)
    }
}
