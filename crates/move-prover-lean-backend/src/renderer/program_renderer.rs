// Copyright (c) Asymptotic Labs
// SPDX-License-Identifier: Apache-2.0

//! Renders complete TheoremProgram to Lean files

use intermediate_theorem_format::TheoremProgram;
use super::function_renderer::FunctionRenderer;
use super::struct_renderer::StructRenderer;
use super::lean_writer::LeanWriter;
use std::fs;
use std::path::Path;

pub struct ProgramRenderer {
    function_renderer: FunctionRenderer,
    struct_renderer: StructRenderer,
}

impl ProgramRenderer {
    pub fn new() -> Self {
        Self {
            function_renderer: FunctionRenderer::new(),
            struct_renderer: StructRenderer::new(),
        }
    }


    /// Render the entire program to a Lean file
    pub fn render_to_file(&self, program: &TheoremProgram, output_path: &Path) -> anyhow::Result<()> {
        let mut output = String::new();

        // Header
        output.push_str("-- Generated by sui-prover\n");
        output.push_str("-- Simple direct translation from TheoremIR\n\n");

        // Render all functions
        for func in program.functions.values() {
            let writer = LeanWriter::new(&program.name_manager);
            self.function_renderer.render(func, program, &writer);
            output.push_str(&writer.extract_result());
            output.push_str("\n");
        }

        // Write to file
        if let Some(parent) = output_path.parent() {
            fs::create_dir_all(parent)?;
        }
        fs::write(output_path, output)?;

        Ok(())
    }

    /// Render program to directory structure (organized by module hierarchy)
    pub fn render_to_directory(&self, program: &TheoremProgram, output_dir: &Path, prelude_imports: &[String]) -> anyhow::Result<()> {
        fs::create_dir_all(output_dir)?;

        // Copy native package implementations from lemmas directory
        self.copy_native_packages(program, output_dir)?;

        // Render each module
        for (&module_id, module) in &program.modules {
            // Skip native modules - they've already been copied
            if program.is_native_module(&module.package_name, &module.name) {
                continue;
            }
            let mut module_output = String::new();

            module_output.push_str(&format!("-- Module: {}\n\n", module.name));

            // Import Prelude modules (dynamically discovered from actual files)
            for prelude_import in prelude_imports {
                module_output.push_str(&format!("import {}\n", prelude_import));
            }

            // Add imports for other modules that this module depends on
            // Use pre-computed imports from IR
            for &required_module_id in &module.required_imports {
                if let Some(required_module) = program.modules.get(&required_module_id) {
                    let import_path = self.module_to_import_path(required_module);
                    module_output.push_str(&format!("import {}\n", import_path));
                }
            }
            module_output.push('\n');

            // Capitalize module name for Lean namespace
            // Avoid conflicts with Lean built-in types/modules
            let namespace_name = if module.name == "vector" {
                "MoveVector".to_string()
            } else {
                Self::capitalize_first(&module.name)
            };

            // Open namespace for this module
            module_output.push_str(&format!("namespace {}\n\n", namespace_name));

            // Render all structs in this module FIRST (before functions that use them)
            // Structs are already topologically sorted globally by DependencyOrderPass
            // Filter to only structs in this module, maintaining global sort order
            for (_, struct_def) in &program.structs {
                if struct_def.module_id == module_id {
                    let writer = LeanWriter::with_module(&program.name_manager, namespace_name.clone());
                    self.struct_renderer.render(struct_def, &writer);
                    module_output.push_str(&writer.extract_result());
                    module_output.push_str("\n");
                }
            }

            // Render all functions in this module
            // Skip functions that have both native implementations AND bytecode bodies
            // The native impl takes precedence
            // Also skip functions that were not translated (have empty bodies)
            // Functions are already globally sorted by DependencyOrderPass
            let mut rendered_functions = std::collections::HashSet::new();
            for (_, func) in &program.functions {
                if func.module_id != module_id {
                    continue;
                }

                // Skip if already rendered (shouldn't happen, but defensive check)
                // Use function ID for deduplication since IDs are globally unique
                if rendered_functions.contains(&func.id) {
                    continue;
                }

                // Skip functions that were not translated (have empty body)
                // Empty body is Statement::Sequence(vec![])
                use intermediate_theorem_format::Statement;
                let is_empty = matches!(func.body, Statement::Sequence(ref stmts) if stmts.is_empty());
                if is_empty {
                    continue;
                }

                let writer = LeanWriter::with_module(&program.name_manager, namespace_name.clone());
                self.function_renderer.render(func, program, &writer);
                let rendered = writer.extract_result();
                // Only add non-empty functions to avoid malformed output
                if !rendered.trim().is_empty() {
                    module_output.push_str(&rendered);
                    module_output.push_str("\n");
                }
                rendered_functions.insert(func.id);
            }

            // Ensure there's a blank line before closing namespace
            if !module_output.ends_with("\n\n") && !module_output.ends_with("namespace") {
                module_output.push('\n');
            }

            // Close namespace
            module_output.push_str(&format!("end {}\n", namespace_name));

            // Get the module file path from stored data
            let module_path = self.get_module_file_path_from_module(module);
            let module_file = output_dir.join(&module_path);

            // Create parent directories if needed
            if let Some(parent) = module_file.parent() {
                fs::create_dir_all(parent)?;
            }

            fs::write(module_file, module_output)?;
        }

        Ok(())
    }

    /// Get module file path from TheoremModule data
    fn get_module_file_path_from_module(&self, module: &intermediate_theorem_format::TheoremModule) -> String {
        let namespace = if module.name == "vector" {
            "MoveVector"
        } else {
            &Self::capitalize_first(&module.name)
        };
        format!("{}/{}.lean", module.package_name, namespace)
    }

    /// Convert a module to its Lean import path
    fn module_to_import_path(
        &self,
        module: &intermediate_theorem_format::TheoremModule,
    ) -> String {
        let namespace = if module.name == "vector" {
            "MoveVector".to_string()
        } else {
            Self::capitalize_first(&module.name)
        };
        format!("Impls.{}.{}", module.package_name, namespace)
    }

    /// Capitalize the first letter of a string (for Lean naming conventions)
    fn capitalize_first(s: &str) -> String {
        let mut chars = s.chars();
        match chars.next() {
            None => String::new(),
            Some(first) => {
                let mut result = first.to_uppercase().collect::<String>();
                result.push_str(chars.as_str());
                result
            }
        }
    }

    /// Copy native package implementations from lemmas directory to output
    fn copy_native_packages(&self, program: &TheoremProgram, output_dir: &Path) -> anyhow::Result<()> {
        use std::collections::HashSet;

        // Get the path to the lemmas directory (in the crate)
        let lemmas_dir = Path::new(env!("CARGO_MANIFEST_DIR")).join("lemmas");

        // Track which modules we've copied
        let mut copied_modules = HashSet::new();

        // For each module in the program
        for module in program.modules.values() {
            if !program.is_native_module(&module.package_name, &module.name) {
                continue;
            }

            // Avoid duplicates
            let module_key = format!("{}::{}", module.package_name, module.name);
            if copied_modules.contains(&module_key) {
                continue;
            }

            // Map module to its lemma file
            let lemma_file = self.get_native_lemma_path(&module.package_name, &module.name);
            let source_path = lemmas_dir.join(&lemma_file);

            if !source_path.exists() {
                // No native implementation available - this is OK, module will be empty
                continue;
            }

            // Determine destination path in output
            let namespace = if module.name == "vector" {
                "MoveVector"
            } else {
                &Self::capitalize_first(&module.name)
            };
            let dest_path = output_dir.join(&module.package_name).join(format!("{}.lean", namespace));

            // Create parent directory
            if let Some(parent) = dest_path.parent() {
                fs::create_dir_all(parent)?;
            }

            // Copy the file
            fs::copy(&source_path, &dest_path)?;

            copied_modules.insert(module_key);
        }

        Ok(())
    }

    /// Get the path to a native lemma file relative to lemmas directory
    fn get_native_lemma_path(&self, package_name: &str, module_name: &str) -> String {
        // MoveStdlib maps to Prelude
        match package_name {
            "MoveStdlib" => {
                // Map module names to their Prelude files
                match module_name {
                    "vector" => "Prelude/Vector.lean".to_string(),
                    _ => format!("Prelude/{}.lean", Self::capitalize_first(module_name)),
                }
            }
            // Other packages would go here
            _ => format!("Impls/{}/{}.lean", package_name, Self::capitalize_first(module_name)),
        }
    }
}
