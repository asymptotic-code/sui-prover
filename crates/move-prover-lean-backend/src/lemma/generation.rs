// Copyright (c) Asymptotic Labs
// SPDX-License-Identifier: Apache-2.0

//! Lemma File Generation
//!
//! This module handles generating Lean lemma files in the output directory structure:
//! - output/Lemmas/Dependencies/{module}/
//! - output/Lemmas/Universal/
//! - Automatic import generation in proof files

use anyhow::{Context, Result};
use log::{error, info};
use std::fs;
use std::path::{Path, PathBuf};

use crate::lemma::cache::{CachedLemma, LemmaCache};

/// Lemma file generator
pub struct LemmaFileGenerator {
    /// Output directory (where Impls/ and Proofs/ are)
    output_dir: PathBuf,

    /// Universal lemmas directory (crates/move-prover-lean-backend/lemmas/)
    universal_dir: PathBuf,
}

impl LemmaFileGenerator {
    /// Create a new lemma file generator
    pub fn new(output_dir: PathBuf) -> Self {
        let universal_dir = Self::find_universal_lemmas_dir(&output_dir);

        Self {
            output_dir,
            universal_dir,
        }
    }

    /// Find the lemmas directory (contains Prelude and Lemmas subdirs)
    fn find_universal_lemmas_dir(output_dir: &Path) -> PathBuf {
        let lemmas_subpath = "crates/move-prover-lean-backend/lemmas";

        // Try walking up from output_dir to find project root
        let mut current = output_dir.to_path_buf();
        while current.pop() {
            let candidate = current.join(lemmas_subpath);
            if candidate.join("Prelude").exists() {
                return candidate;
            }
        }

        // Try current working directory
        if let Ok(cwd) = std::env::current_dir() {
            let candidate = cwd.join(lemmas_subpath);
            if candidate.join("Prelude").exists() {
                return candidate;
            }

            // Try parent of current working directory
            if let Some(parent) = cwd.parent() {
                let candidate = parent.join(lemmas_subpath);
                if candidate.join("Prelude").exists() {
                    return candidate;
                }
            }
        }

        // Fallback to relative path from output_dir
        output_dir.join("../../").join(lemmas_subpath)
    }

    /// Initialize the Lemmas/ and Prelude/ directory structure
    pub fn initialize_directories(&self) -> Result<()> {
        let lemmas_dir = self.output_dir.join("Lemmas");

        // Create subdirectories for generated lemmas
        fs::create_dir_all(lemmas_dir.join("Dependencies"))
            .context("Failed to create Lemmas/Dependencies")?;
        fs::create_dir_all(lemmas_dir.join("AutoGenerated"))
            .context("Failed to create Lemmas/AutoGenerated")?;

        // Copy Prelude type definitions from project root to output
        self.copy_universal_files()
            .context("Failed to copy Prelude files")?;

        Ok(())
    }

    /// Get list of Prelude module names from source directory
    /// Returns module names like "Prelude.UInt128", "Prelude.Helpers", etc.
    pub fn get_prelude_imports(&self) -> Result<Vec<String>> {
        let prelude_source = self.universal_dir.join("Prelude");

        if !prelude_source.exists() {
            return Ok(vec![]);
        }

        let entries = fs::read_dir(&prelude_source)
            .context("Failed to read Prelude directory")?;

        let mut imports = Vec::new();
        for entry in entries.flatten() {
            let path = entry.path();
            if path.extension().and_then(|s| s.to_str()) == Some("lean") {
                if let Some(file_stem) = path.file_stem().and_then(|s| s.to_str()) {
                    imports.push(format!("Prelude.{}", file_stem));
                }
            }
        }

        // Sort for consistent ordering
        imports.sort();
        Ok(imports)
    }

    /// Copy Prelude files from lean backend to output directory
    fn copy_universal_files(&self) -> Result<()> {
        let prelude_source = self.universal_dir.join("Prelude");

        if !prelude_source.exists() {
            error!(
                "Prelude directory not found at: {}",
                prelude_source.display()
            );
            return Ok(());
        }

        info!(
            "Copying Prelude files from: {}",
            prelude_source.display()
        );

        let output_prelude = self.output_dir.join("Prelude");
        fs::create_dir_all(&output_prelude)
            .context("Failed to create Prelude directory")?;

        let entries = fs::read_dir(&prelude_source)
            .context("Failed to read Prelude directory")?;

        for entry in entries.flatten() {
            let path = entry.path();
            if path.extension().and_then(|s| s.to_str()) == Some("lean") {
                if let Some(file_name) = path.file_name() {
                    let dest = output_prelude.join(file_name);
                    fs::copy(&path, &dest).with_context(|| {
                        format!("Failed to copy {} to {}", path.display(), dest.display())
                    })?;
                }
            }
        }

        // Note: Lemmas/ directory removed - only Prelude type definitions are needed

        Ok(())
    }

    /// Generate a lemma file for a specific module's dependency lemmas
    pub fn generate_dependency_lemma_file(
        &self,
        module_name: &str,
        lemmas: &[&CachedLemma],
    ) -> Result<PathBuf> {
        if lemmas.is_empty() {
            return Ok(PathBuf::new());
        }

        let is_universal = module_name.starts_with("Universal/");
        let module_path = module_name.replace("/", std::path::MAIN_SEPARATOR_STR);

        let module_dir = if is_universal {
            let category = module_name.strip_prefix("Universal/").unwrap_or(module_name);
            self.output_dir
                .join("Lemmas")
                .join("Universal")
                .join(category)
        } else {
            self.output_dir
                .join("Lemmas")
                .join("Dependencies")
                .join(&module_path)
        };

        fs::create_dir_all(&module_dir)
            .context("Failed to create module lemma directory")?;

        let file_name = format!("{}_properties.lean", module_name.replace("/", "_"));
        let file_path = module_dir.join(file_name);

        let import_path = module_name.replace("/", ".");
        let namespace = module_name.replace("/", "_");

        let mut content = String::new();
        content.push_str("-- Lemmas for dependency functions\n");
        content.push_str(&format!("import Impls.{}\n\n", import_path));
        content.push_str(&format!("namespace {}\n\n", namespace));

        for lemma in lemmas {
            content.push_str(&format!("-- {}\n", lemma.lemma_id));
            content.push_str(&format!("-- Category: {}\n", lemma.category));
            content.push_str(&format!("-- Generation: {:?}\n", lemma.generation_method));

            if !lemma.dependencies.is_empty() {
                content.push_str(&format!("-- Dependencies: {:?}\n", lemma.dependencies));
            }

            content.push_str(&lemma.statement);

            if let Some(proof) = &lemma.proof {
                content.push_str(" := by\n  ");
                content.push_str(proof);
                content.push_str("\n\n");
            } else {
                content.push_str(" := by\n  sorry\n\n");
            }
        }

        content.push_str(&format!("end {}\n", namespace));

        fs::write(&file_path, content).context("Failed to write lemma file")?;

        Ok(file_path)
    }

    /// Create the lemma registry JSON file
    pub fn create_lemma_registry(&self, cache: &LemmaCache) -> Result<()> {
        let registry_path = self.output_dir.join("Lemmas").join("lemma_registry.json");

        #[derive(serde::Serialize)]
        struct LemmaRegistry<'a> {
            version: &'static str,
            project_hash: &'a str,
            total_lemmas: usize,
            proven_lemmas: usize,
            candidate_lemmas: usize,
            modules: Vec<ModuleInfo<'a>>,
        }

        #[derive(serde::Serialize)]
        struct ModuleInfo<'a> {
            module: &'a str,
            lemma_count: usize,
            lemma_ids: Vec<&'a str>,
        }

        let mut modules_map: std::collections::HashMap<&str, Vec<&str>> =
            std::collections::HashMap::new();

        for lemma in cache.lemmas.values() {
            modules_map
                .entry(&lemma.module)
                .or_default()
                .push(&lemma.lemma_id);
        }

        let modules: Vec<_> = modules_map
            .iter()
            .map(|(module, ids)| ModuleInfo {
                module,
                lemma_count: ids.len(),
                lemma_ids: ids.clone(),
            })
            .collect();

        let registry = LemmaRegistry {
            version: "1.0",
            project_hash: &cache.project_hash,
            total_lemmas: cache.lemmas.len(),
            proven_lemmas: cache.proven_lemmas().count(),
            candidate_lemmas: cache
                .lemmas
                .values()
                .filter(|l| matches!(l.status, crate::lemma::cache::LemmaStatus::Candidate))
                .count(),
            modules,
        };

        let content = serde_json::to_string_pretty(&registry)?;
        fs::write(registry_path, content)?;

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;
    use crate::lemma::cache::*;

    #[test]
    fn test_initialize_directories() {
        let temp_dir = TempDir::new().unwrap();
        let generator = LemmaFileGenerator::new(temp_dir.path().to_path_buf());

        generator.initialize_directories().unwrap();

        assert!(temp_dir.path().join("Lemmas/Dependencies").exists());
        assert!(temp_dir.path().join("Lemmas/AutoGenerated").exists());
        // Note: Prelude is copied from source, not created as empty directory
    }

    #[test]
    fn test_generate_dependency_lemma_file() {
        let temp_dir = TempDir::new().unwrap();
        let generator = LemmaFileGenerator::new(temp_dir.path().to_path_buf());
        generator.initialize_directories().unwrap();

        let lemma = CachedLemma {
            lemma_id: "test_lemma".to_string(),
            module: "TestModule".to_string(),
            function: Some("test_fn".to_string()),
            category: "monotonicity".to_string(),
            statement: "lemma test_lemma : True".to_string(),
            proof: Some("trivial".to_string()),
            dependencies: vec![],
            status: LemmaStatus::Proven,
            generation_method: GenerationMethod::Manual,
            confidence: 1.0,
            difficulty: Difficulty::Easy,
            used_by: vec![],
            created_at: chrono::Utc::now(),
            proven_at: Some(chrono::Utc::now()),
            proof_time_ms: Some(100),
            version: 1,
        };

        let path = generator.generate_dependency_lemma_file("TestModule", &[&lemma]).unwrap();
        assert!(path.exists());

        let content = fs::read_to_string(&path).unwrap();
        assert!(content.contains("import Impls.TestModule"));
        assert!(content.contains("test_lemma"));
        assert!(content.contains("trivial"));
    }
}
