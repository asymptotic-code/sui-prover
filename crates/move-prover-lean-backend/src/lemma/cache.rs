// Copyright (c) Asymptotic Labs
// SPDX-License-Identifier: Apache-2.0

//! Lemma Cache System
//!
//! This module provides persistent caching of proven lemmas and proof strategies
//! across Sui Prover runs. It enables:
//! - Reuse of proven lemmas without re-proving
//! - Sharing of proof strategies that worked
//! - Incremental verification (only re-prove what changed)
//! - Cross-project lemma sharing (via global cache)

use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fs;
use std::path::{Path, PathBuf};
use sha2::{Digest, Sha256};

/// Cache format version for forward compatibility
const CACHE_VERSION: &str = "1.0";

/// Default cache directory in user's home
const DEFAULT_CACHE_DIR: &str = ".sui-prover/lemma-cache";

/// Lemma metadata and proof information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CachedLemma {
    /// Unique identifier for this lemma
    pub lemma_id: String,

    /// Module where this lemma applies
    pub module: String,

    /// Function this lemma is about (if applicable)
    pub function: Option<String>,

    /// Category of lemma (monotonicity, bounds, composition, etc.)
    pub category: String,

    /// Lean statement of the lemma
    pub statement: String,

    /// Lean proof (if proven)
    pub proof: Option<String>,

    /// Dependencies (other lemma IDs this depends on)
    pub dependencies: Vec<String>,

    /// Proof status
    pub status: LemmaStatus,

    /// How this lemma was generated
    pub generation_method: GenerationMethod,

    /// Confidence score (0.0 to 1.0) for AI-generated lemmas
    pub confidence: f64,

    /// Difficulty estimate (easy, medium, hard)
    pub difficulty: Difficulty,

    /// Functions/proofs that use this lemma
    pub used_by: Vec<String>,

    /// Timestamp when lemma was created
    pub created_at: chrono::DateTime<chrono::Utc>,

    /// Timestamp when lemma was proven (if proven)
    pub proven_at: Option<chrono::DateTime<chrono::Utc>>,

    /// Time taken to prove (milliseconds)
    pub proof_time_ms: Option<u64>,

    /// Version number for this lemma
    pub version: u32,
}

/// Status of a lemma
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum LemmaStatus {
    /// Generated but not yet attempted
    Candidate,
    /// Attempted but failed to prove
    Failed,
    /// Successfully proven
    Proven,
    /// Proven but invalidated due to code changes
    Invalidated,
}

/// How a lemma was generated
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum GenerationMethod {
    /// Manually written by user
    Manual,
    /// Generated by AI/pattern matching
    AIInference,
    /// Instantiated from template
    Template,
    /// Extracted from successful proof
    ProofMining,
}

/// Difficulty estimate
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum Difficulty {
    Easy,
    Medium,
    Hard,
    Unknown,
}

/// Proof strategy that worked for a class of lemmas
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ProofStrategy {
    /// Unique name for this strategy
    pub name: String,

    /// Pattern description (what kind of lemmas this applies to)
    pub pattern: String,

    /// Sequence of Lean tactics
    pub tactics: Vec<String>,

    /// Success rate (0.0 to 1.0)
    pub success_rate: f64,

    /// Number of times this strategy succeeded
    pub success_count: u32,

    /// Number of times this strategy was attempted
    pub attempt_count: u32,

    /// Example lemma IDs where this worked
    pub examples: Vec<String>,
}

/// Main lemma cache structure
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LemmaCache {
    /// Cache format version
    pub cache_version: String,

    /// Hash of the project's Move source files
    pub project_hash: String,

    /// Map from lemma_id to lemma data
    pub lemmas: HashMap<String, CachedLemma>,

    /// Proof strategies
    pub strategies: HashMap<String, ProofStrategy>,

    /// Timestamp of last update
    pub last_updated: chrono::DateTime<chrono::Utc>,
}

impl LemmaCache {
    /// Create a new empty cache for a project
    pub fn new(project_hash: String) -> Self {
        Self {
            cache_version: CACHE_VERSION.to_string(),
            project_hash,
            lemmas: HashMap::new(),
            strategies: HashMap::new(),
            last_updated: chrono::Utc::now(),
        }
    }

    /// Add or update a lemma in the cache
    pub fn add_lemma(&mut self, lemma: CachedLemma) {
        self.lemmas.insert(lemma.lemma_id.clone(), lemma);
        self.last_updated = chrono::Utc::now();
    }

    /// Get a lemma by ID
    pub fn get_lemma(&self, lemma_id: &str) -> Option<&CachedLemma> {
        self.lemmas.get(lemma_id)
    }

    /// Get all proven lemmas
    pub fn proven_lemmas(&self) -> impl Iterator<Item = &CachedLemma> {
        self.lemmas.values().filter(|l| l.status == LemmaStatus::Proven)
    }

    /// Get lemmas for a specific module
    pub fn lemmas_for_module<'a>(&'a self, module: &'a str) -> impl Iterator<Item = &'a CachedLemma> + 'a {
        self.lemmas.values().filter(move |l| l.module == module)
    }

    /// Get lemmas for a specific function
    pub fn lemmas_for_function<'a>(&'a self, module: &'a str, function: &'a str) -> impl Iterator<Item = &'a CachedLemma> + 'a {
        self.lemmas.values().filter(move |l| {
            l.module == module && l.function.as_deref() == Some(function)
        })
    }

    /// Add or update a proof strategy
    pub fn add_strategy(&mut self, strategy: ProofStrategy) {
        self.strategies.insert(strategy.name.clone(), strategy);
        self.last_updated = chrono::Utc::now();
    }

    /// Get a proof strategy by name
    pub fn get_strategy(&self, name: &str) -> Option<&ProofStrategy> {
        self.strategies.get(name)
    }

    /// Invalidate lemmas when code changes
    pub fn invalidate_changed_lemmas(&mut self, changed_modules: &[String]) {
        for lemma in self.lemmas.values_mut() {
            if changed_modules.contains(&lemma.module) && lemma.status == LemmaStatus::Proven {
                lemma.status = LemmaStatus::Invalidated;
            }
        }
        self.last_updated = chrono::Utc::now();
    }

    /// Remove invalidated lemmas older than a certain age
    pub fn prune_old_invalidated(&mut self, days: i64) {
        let cutoff = chrono::Utc::now() - chrono::Duration::days(days);
        self.lemmas.retain(|_, lemma| {
            lemma.status != LemmaStatus::Invalidated || lemma.created_at > cutoff
        });
        self.last_updated = chrono::Utc::now();
    }
}

/// Cache manager handles loading, saving, and managing caches
pub struct LemmaCacheManager {
    /// Root directory for all caches
    cache_root: PathBuf,

    /// Current project cache
    current_cache: Option<LemmaCache>,
}

impl LemmaCacheManager {
    /// Create a new cache manager with default cache directory
    pub fn new() -> Result<Self> {
        let cache_root = Self::default_cache_dir()?;
        fs::create_dir_all(&cache_root)
            .context("Failed to create cache directory")?;

        Ok(Self {
            cache_root,
            current_cache: None,
        })
    }

    /// Create a cache manager with a custom cache directory
    pub fn with_cache_dir(cache_dir: PathBuf) -> Result<Self> {
        fs::create_dir_all(&cache_dir)
            .context("Failed to create cache directory")?;

        Ok(Self {
            cache_root: cache_dir,
            current_cache: None,
        })
    }

    /// Get the default cache directory (~/.sui-prover/lemma-cache)
    fn default_cache_dir() -> Result<PathBuf> {
        let home = dirs::home_dir()
            .context("Could not determine home directory")?;
        Ok(home.join(DEFAULT_CACHE_DIR))
    }

    /// Load cache for a specific project
    pub fn load_project_cache(&mut self, project_path: &Path) -> Result<&LemmaCache> {
        let project_hash = Self::hash_project(project_path)?;
        let cache_path = self.cache_root
            .join("project_caches")
            .join(&project_hash)
            .join("lemmas.json");

        if cache_path.exists() {
            let content = fs::read_to_string(&cache_path)
                .context("Failed to read cache file")?;
            let cache: LemmaCache = serde_json::from_str(&content)
                .context("Failed to parse cache file")?;

            // Verify cache version
            if cache.cache_version != CACHE_VERSION {
                // Cache version mismatch - create new cache
                self.current_cache = Some(LemmaCache::new(project_hash));
            } else {
                self.current_cache = Some(cache);
            }
        } else {
            // Create new cache
            self.current_cache = Some(LemmaCache::new(project_hash));
        }

        Ok(self.current_cache.as_ref().unwrap())
    }

    /// Save the current project cache
    pub fn save_project_cache(&self, project_path: &Path) -> Result<()> {
        if let Some(cache) = &self.current_cache {
            let project_hash = Self::hash_project(project_path)?;
            let cache_dir = self.cache_root
                .join("project_caches")
                .join(&project_hash);
            fs::create_dir_all(&cache_dir)
                .context("Failed to create project cache directory")?;

            let cache_path = cache_dir.join("lemmas.json");
            let content = serde_json::to_string_pretty(cache)
                .context("Failed to serialize cache")?;
            fs::write(&cache_path, content)
                .context("Failed to write cache file")?;
        }

        Ok(())
    }


    /// Get mutable reference to current project cache
    pub fn current_cache_mut(&mut self) -> Option<&mut LemmaCache> {
        self.current_cache.as_mut()
    }

    /// Get reference to current project cache
    pub fn current_cache(&self) -> Option<&LemmaCache> {
        self.current_cache.as_ref()
    }

    /// Find a lemma in the current project cache
    pub fn find_lemma(&self, lemma_id: &str) -> Option<&CachedLemma> {
        self.current_cache.as_ref()?.get_lemma(lemma_id)
    }

    /// Compute hash of project source files for cache invalidation
    fn hash_project(project_path: &Path) -> Result<String> {
        let mut hasher = Sha256::new();

        // Find all .move files in the project
        let move_files = Self::find_move_files(project_path)?;

        // Sort for deterministic hashing
        let mut move_files = move_files;
        move_files.sort();

        // Hash each file's content
        for file in move_files {
            let content = fs::read_to_string(&file)
                .with_context(|| format!("Failed to read {}", file.display()))?;
            hasher.update(content.as_bytes());
            hasher.update(b"\0"); // Separator
        }

        let hash = hasher.finalize();
        Ok(format!("{:x}", hash))
    }

    /// Find all .move files in a directory recursively
    fn find_move_files(dir: &Path) -> Result<Vec<PathBuf>> {
        let mut files = Vec::new();

        if dir.is_dir() {
            for entry in fs::read_dir(dir)
                .with_context(|| format!("Failed to read directory {}", dir.display()))?
            {
                let entry = entry?;
                let path = entry.path();

                if path.is_dir() {
                    files.extend(Self::find_move_files(&path)?);
                } else if path.extension().and_then(|s| s.to_str()) == Some("move") {
                    files.push(path);
                }
            }
        }

        Ok(files)
    }
}

impl Default for LemmaCacheManager {
    fn default() -> Self {
        Self::new().expect("Failed to create default cache manager")
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_cache_creation() {
        let cache = LemmaCache::new("test_hash".to_string());
        assert_eq!(cache.cache_version, CACHE_VERSION);
        assert_eq!(cache.project_hash, "test_hash");
        assert!(cache.lemmas.is_empty());
        assert!(cache.strategies.is_empty());
    }

    #[test]
    fn test_add_lemma() {
        let mut cache = LemmaCache::new("test_hash".to_string());

        let lemma = CachedLemma {
            lemma_id: "test_lemma".to_string(),
            module: "TestModule".to_string(),
            function: Some("test_fn".to_string()),
            category: "monotonicity".to_string(),
            statement: "theorem test : True := by trivial".to_string(),
            proof: Some("trivial".to_string()),
            dependencies: vec![],
            status: LemmaStatus::Proven,
            generation_method: GenerationMethod::Manual,
            confidence: 1.0,
            difficulty: Difficulty::Easy,
            used_by: vec![],
            created_at: chrono::Utc::now(),
            proven_at: Some(chrono::Utc::now()),
            proof_time_ms: Some(100),
            version: 1,
        };

        cache.add_lemma(lemma.clone());
        assert_eq!(cache.lemmas.len(), 1);
        assert_eq!(cache.get_lemma("test_lemma").unwrap().module, "TestModule");
    }

    #[test]
    fn test_filter_proven_lemmas() {
        let mut cache = LemmaCache::new("test_hash".to_string());

        // Add proven lemma
        let lemma1 = CachedLemma {
            lemma_id: "proven".to_string(),
            module: "M".to_string(),
            function: None,
            category: "test".to_string(),
            statement: "test".to_string(),
            proof: Some("proof".to_string()),
            dependencies: vec![],
            status: LemmaStatus::Proven,
            generation_method: GenerationMethod::Manual,
            confidence: 1.0,
            difficulty: Difficulty::Easy,
            used_by: vec![],
            created_at: chrono::Utc::now(),
            proven_at: Some(chrono::Utc::now()),
            proof_time_ms: Some(100),
            version: 1,
        };

        // Add candidate lemma
        let lemma2 = CachedLemma {
            lemma_id: "candidate".to_string(),
            status: LemmaStatus::Candidate,
            ..lemma1.clone()
        };

        cache.add_lemma(lemma1);
        cache.add_lemma(lemma2);

        let proven: Vec<_> = cache.proven_lemmas().collect();
        assert_eq!(proven.len(), 1);
        assert_eq!(proven[0].lemma_id, "proven");
    }
}
