
use anyhow::Result;
use lambda_runtime::{service_fn, Error, LambdaEvent};
use rustls::crypto::CryptoProvider;
use crate::handler::ProverHandler;
use serde_json::{from_str, json, Value};
use dotenv;

pub mod handler;

fn make_error_response(status_code: u16, error: &str) -> Value {
    json!({
        "statusCode": status_code,
        "headers": {
            "Content-Type": "application/json"
        },
        "body": {
            "error": error
        }
    })
}

fn make_success_response(body: String) -> Value {
    json!({
        "statusCode": 200,
        "headers": {
            "Content-Type": "application/json"
        },
        "body": body.to_string()
    })
}

fn security_check(event: Value) -> Option<Value> {
    if event.get("headers").is_none() || event.get("headers").unwrap().as_object().is_none() {
        return Some(make_error_response(400, "Headers are missing or invalid."));
    }

    let auth_header: Option<&Value> = event.get("headers").unwrap().as_object().unwrap()
        .get("Authorization")
        .or_else(|| event.get("headers").unwrap().as_object().unwrap().get("authorization"));

    if auth_header.is_none() || auth_header.unwrap().as_str().is_none() {
        return Some(make_error_response(401, "Authorization header is missing or invalid."));
    }

    let auth_value = auth_header.unwrap().as_str().unwrap();
    let allowed = std::env::var("ALLOWED_KEY_HASHES_CSV")
        .unwrap_or_else(|_| "".to_string())
        .split(',')
        .map(|s| s.trim().to_string())
        .collect::<Vec<String>>();

    if allowed.is_empty() {
        return None;
    }

    if !allowed.contains(&ProverHandler::generate_hash(auth_value)) {
        Some(make_error_response(403, "Forbidden"))
    } else {
        None
    }
}

async fn handler(event: LambdaEvent<Value>) -> Result<Value, Error> {
    dotenv::dotenv().ok();

    match CryptoProvider::install_default(rustls::crypto::ring::default_provider()) {
        Ok(_) => {}
        Err(_) => { /* Provider is already installed, we can ignore the error */ }
    }

    let (event, _context) = event.into_parts();

    let security_response = security_check(event.clone());
    if security_response.is_some() {
        return Ok(security_response.unwrap());
    }

    if event.get("body").is_none() || event.get("body").unwrap().as_str().is_none() {
        return Ok(make_error_response(400, "Body is missing or invalid."));
    }

    let body_value: Value = from_str(event.get("body").unwrap().as_str().unwrap()).unwrap();
    let body = body_value.as_object().unwrap();

    if body.get("file_text").is_none() || body.get("file_text").unwrap().as_str().is_none() {
        return Ok(make_error_response(400, "File text is missing."));
    }

    let file_text = body.get("file_text").unwrap().as_str().unwrap().to_string();

    let prover = ProverHandler::new(false)?;

    let response = match prover.process(file_text).await {
        Ok(resp) => resp,
        Err(e) => {
            return Ok(make_error_response(500, &format!("Prover processing failed: {}", e)));
        }
    };

    let response_body = serde_json::to_string(&response).unwrap();

    Ok(make_success_response(response_body))
}

#[tokio::main]
async fn main() -> Result<(), Error> {
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::INFO)
        .init();
    
    let func = service_fn(handler);
    lambda_runtime::run(func).await
}

#[tokio::test]
async fn local_handler() -> Result<()> {
    let file_path = "<>/sui-kit/examples/amm/output/spec_no_abort_check.bpl";
    let file_text = match std::fs::read_to_string(file_path) {
        Ok(content) => content,
        Err(e) => {
            println!("❌ Failed to read test file: {}", e);
            println!("⚠️  Test skipped because test file is not available");
            return Ok(());
        }
    };

    let prover = ProverHandler::new(true).unwrap();
    prover.process(file_text).await.unwrap();

    Ok(())
}
